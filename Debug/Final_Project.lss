
Final_Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000c2c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000004a  00800060  00000c2c  00000cc0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000003  008000aa  008000aa  00000d0a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d0a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000d3c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000228  00000000  00000000  00000d78  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002255  00000000  00000000  00000fa0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c02  00000000  00000000  000031f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001aa3  00000000  00000000  00003df7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000004e8  00000000  00000000  0000589c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000008b7  00000000  00000000  00005d84  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000240b  00000000  00000000  0000663b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001f8  00000000  00000000  00008a46  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 94 05 	jmp	0xb28	; 0xb28 <__vector_1>
   8:	0c 94 bc 05 	jmp	0xb78	; 0xb78 <__vector_2>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 e9 05 	jmp	0xbd2	; 0xbd2 <__vector_9>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ec e2       	ldi	r30, 0x2C	; 44
  68:	fc e0       	ldi	r31, 0x0C	; 12
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	aa 3a       	cpi	r26, 0xAA	; 170
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	aa ea       	ldi	r26, 0xAA	; 170
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	ad 3a       	cpi	r26, 0xAD	; 173
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 75 05 	call	0xaea	; 0xaea <main>
  8a:	0c 94 14 06 	jmp	0xc28	; 0xc28 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_vsetPINDir>:
		break ;
		case 'C' :
		PORTC&=0x0f;//set the value of the high nibble of the port C as low
		break ;
		case 'D':
		PORTD&=0x0f;//set the value of the high nibble of the port D as low
  92:	82 34       	cpi	r24, 0x42	; 66
  94:	19 f1       	breq	.+70     	; 0xdc <DIO_vsetPINDir+0x4a>
  96:	18 f4       	brcc	.+6      	; 0x9e <DIO_vsetPINDir+0xc>
  98:	81 34       	cpi	r24, 0x41	; 65
  9a:	39 f0       	breq	.+14     	; 0xaa <DIO_vsetPINDir+0x18>
  9c:	08 95       	ret
  9e:	83 34       	cpi	r24, 0x43	; 67
  a0:	b1 f1       	breq	.+108    	; 0x10e <DIO_vsetPINDir+0x7c>
  a2:	84 34       	cpi	r24, 0x44	; 68
  a4:	09 f4       	brne	.+2      	; 0xa8 <DIO_vsetPINDir+0x16>
  a6:	4c c0       	rjmp	.+152    	; 0x140 <DIO_vsetPINDir+0xae>
  a8:	08 95       	ret
  aa:	41 30       	cpi	r20, 0x01	; 1
  ac:	59 f4       	brne	.+22     	; 0xc4 <DIO_vsetPINDir+0x32>
  ae:	2a b3       	in	r18, 0x1a	; 26
  b0:	81 e0       	ldi	r24, 0x01	; 1
  b2:	90 e0       	ldi	r25, 0x00	; 0
  b4:	02 c0       	rjmp	.+4      	; 0xba <DIO_vsetPINDir+0x28>
  b6:	88 0f       	add	r24, r24
  b8:	99 1f       	adc	r25, r25
  ba:	6a 95       	dec	r22
  bc:	e2 f7       	brpl	.-8      	; 0xb6 <DIO_vsetPINDir+0x24>
  be:	82 2b       	or	r24, r18
  c0:	8a bb       	out	0x1a, r24	; 26
  c2:	08 95       	ret
  c4:	2a b3       	in	r18, 0x1a	; 26
  c6:	81 e0       	ldi	r24, 0x01	; 1
  c8:	90 e0       	ldi	r25, 0x00	; 0
  ca:	02 c0       	rjmp	.+4      	; 0xd0 <DIO_vsetPINDir+0x3e>
  cc:	88 0f       	add	r24, r24
  ce:	99 1f       	adc	r25, r25
  d0:	6a 95       	dec	r22
  d2:	e2 f7       	brpl	.-8      	; 0xcc <DIO_vsetPINDir+0x3a>
  d4:	80 95       	com	r24
  d6:	82 23       	and	r24, r18
  d8:	8a bb       	out	0x1a, r24	; 26
  da:	08 95       	ret
  dc:	41 30       	cpi	r20, 0x01	; 1
  de:	59 f4       	brne	.+22     	; 0xf6 <DIO_vsetPINDir+0x64>
  e0:	27 b3       	in	r18, 0x17	; 23
  e2:	81 e0       	ldi	r24, 0x01	; 1
  e4:	90 e0       	ldi	r25, 0x00	; 0
  e6:	02 c0       	rjmp	.+4      	; 0xec <DIO_vsetPINDir+0x5a>
  e8:	88 0f       	add	r24, r24
  ea:	99 1f       	adc	r25, r25
  ec:	6a 95       	dec	r22
  ee:	e2 f7       	brpl	.-8      	; 0xe8 <DIO_vsetPINDir+0x56>
  f0:	82 2b       	or	r24, r18
  f2:	87 bb       	out	0x17, r24	; 23
  f4:	08 95       	ret
  f6:	27 b3       	in	r18, 0x17	; 23
  f8:	81 e0       	ldi	r24, 0x01	; 1
  fa:	90 e0       	ldi	r25, 0x00	; 0
  fc:	02 c0       	rjmp	.+4      	; 0x102 <DIO_vsetPINDir+0x70>
  fe:	88 0f       	add	r24, r24
 100:	99 1f       	adc	r25, r25
 102:	6a 95       	dec	r22
 104:	e2 f7       	brpl	.-8      	; 0xfe <DIO_vsetPINDir+0x6c>
 106:	80 95       	com	r24
 108:	82 23       	and	r24, r18
 10a:	87 bb       	out	0x17, r24	; 23
 10c:	08 95       	ret
 10e:	41 30       	cpi	r20, 0x01	; 1
 110:	59 f4       	brne	.+22     	; 0x128 <DIO_vsetPINDir+0x96>
 112:	24 b3       	in	r18, 0x14	; 20
 114:	81 e0       	ldi	r24, 0x01	; 1
 116:	90 e0       	ldi	r25, 0x00	; 0
 118:	02 c0       	rjmp	.+4      	; 0x11e <DIO_vsetPINDir+0x8c>
 11a:	88 0f       	add	r24, r24
 11c:	99 1f       	adc	r25, r25
 11e:	6a 95       	dec	r22
 120:	e2 f7       	brpl	.-8      	; 0x11a <DIO_vsetPINDir+0x88>
 122:	82 2b       	or	r24, r18
 124:	84 bb       	out	0x14, r24	; 20
 126:	08 95       	ret
 128:	24 b3       	in	r18, 0x14	; 20
 12a:	81 e0       	ldi	r24, 0x01	; 1
 12c:	90 e0       	ldi	r25, 0x00	; 0
 12e:	02 c0       	rjmp	.+4      	; 0x134 <DIO_vsetPINDir+0xa2>
 130:	88 0f       	add	r24, r24
 132:	99 1f       	adc	r25, r25
 134:	6a 95       	dec	r22
 136:	e2 f7       	brpl	.-8      	; 0x130 <DIO_vsetPINDir+0x9e>
 138:	80 95       	com	r24
 13a:	82 23       	and	r24, r18
 13c:	84 bb       	out	0x14, r24	; 20
 13e:	08 95       	ret
 140:	41 30       	cpi	r20, 0x01	; 1
 142:	59 f4       	brne	.+22     	; 0x15a <DIO_vsetPINDir+0xc8>
 144:	21 b3       	in	r18, 0x11	; 17
 146:	81 e0       	ldi	r24, 0x01	; 1
 148:	90 e0       	ldi	r25, 0x00	; 0
 14a:	02 c0       	rjmp	.+4      	; 0x150 <DIO_vsetPINDir+0xbe>
 14c:	88 0f       	add	r24, r24
 14e:	99 1f       	adc	r25, r25
 150:	6a 95       	dec	r22
 152:	e2 f7       	brpl	.-8      	; 0x14c <DIO_vsetPINDir+0xba>
 154:	82 2b       	or	r24, r18
 156:	81 bb       	out	0x11, r24	; 17
 158:	08 95       	ret
 15a:	21 b3       	in	r18, 0x11	; 17
 15c:	81 e0       	ldi	r24, 0x01	; 1
 15e:	90 e0       	ldi	r25, 0x00	; 0
 160:	02 c0       	rjmp	.+4      	; 0x166 <DIO_vsetPINDir+0xd4>
 162:	88 0f       	add	r24, r24
 164:	99 1f       	adc	r25, r25
 166:	6a 95       	dec	r22
 168:	e2 f7       	brpl	.-8      	; 0x162 <DIO_vsetPINDir+0xd0>
 16a:	80 95       	com	r24
 16c:	82 23       	and	r24, r18
 16e:	81 bb       	out	0x11, r24	; 17
 170:	08 95       	ret

00000172 <DIO_write>:
 172:	82 34       	cpi	r24, 0x42	; 66
 174:	19 f1       	breq	.+70     	; 0x1bc <DIO_write+0x4a>
 176:	18 f4       	brcc	.+6      	; 0x17e <DIO_write+0xc>
 178:	81 34       	cpi	r24, 0x41	; 65
 17a:	39 f0       	breq	.+14     	; 0x18a <DIO_write+0x18>
 17c:	08 95       	ret
 17e:	83 34       	cpi	r24, 0x43	; 67
 180:	b1 f1       	breq	.+108    	; 0x1ee <DIO_write+0x7c>
 182:	84 34       	cpi	r24, 0x44	; 68
 184:	09 f4       	brne	.+2      	; 0x188 <DIO_write+0x16>
 186:	4c c0       	rjmp	.+152    	; 0x220 <DIO_write+0xae>
 188:	08 95       	ret
 18a:	41 30       	cpi	r20, 0x01	; 1
 18c:	59 f4       	brne	.+22     	; 0x1a4 <DIO_write+0x32>
 18e:	2b b3       	in	r18, 0x1b	; 27
 190:	81 e0       	ldi	r24, 0x01	; 1
 192:	90 e0       	ldi	r25, 0x00	; 0
 194:	02 c0       	rjmp	.+4      	; 0x19a <DIO_write+0x28>
 196:	88 0f       	add	r24, r24
 198:	99 1f       	adc	r25, r25
 19a:	6a 95       	dec	r22
 19c:	e2 f7       	brpl	.-8      	; 0x196 <DIO_write+0x24>
 19e:	82 2b       	or	r24, r18
 1a0:	8b bb       	out	0x1b, r24	; 27
 1a2:	08 95       	ret
 1a4:	2b b3       	in	r18, 0x1b	; 27
 1a6:	81 e0       	ldi	r24, 0x01	; 1
 1a8:	90 e0       	ldi	r25, 0x00	; 0
 1aa:	02 c0       	rjmp	.+4      	; 0x1b0 <DIO_write+0x3e>
 1ac:	88 0f       	add	r24, r24
 1ae:	99 1f       	adc	r25, r25
 1b0:	6a 95       	dec	r22
 1b2:	e2 f7       	brpl	.-8      	; 0x1ac <DIO_write+0x3a>
 1b4:	80 95       	com	r24
 1b6:	82 23       	and	r24, r18
 1b8:	8b bb       	out	0x1b, r24	; 27
 1ba:	08 95       	ret
 1bc:	41 30       	cpi	r20, 0x01	; 1
 1be:	59 f4       	brne	.+22     	; 0x1d6 <DIO_write+0x64>
 1c0:	28 b3       	in	r18, 0x18	; 24
 1c2:	81 e0       	ldi	r24, 0x01	; 1
 1c4:	90 e0       	ldi	r25, 0x00	; 0
 1c6:	02 c0       	rjmp	.+4      	; 0x1cc <DIO_write+0x5a>
 1c8:	88 0f       	add	r24, r24
 1ca:	99 1f       	adc	r25, r25
 1cc:	6a 95       	dec	r22
 1ce:	e2 f7       	brpl	.-8      	; 0x1c8 <DIO_write+0x56>
 1d0:	82 2b       	or	r24, r18
 1d2:	88 bb       	out	0x18, r24	; 24
 1d4:	08 95       	ret
 1d6:	28 b3       	in	r18, 0x18	; 24
 1d8:	81 e0       	ldi	r24, 0x01	; 1
 1da:	90 e0       	ldi	r25, 0x00	; 0
 1dc:	02 c0       	rjmp	.+4      	; 0x1e2 <DIO_write+0x70>
 1de:	88 0f       	add	r24, r24
 1e0:	99 1f       	adc	r25, r25
 1e2:	6a 95       	dec	r22
 1e4:	e2 f7       	brpl	.-8      	; 0x1de <DIO_write+0x6c>
 1e6:	80 95       	com	r24
 1e8:	82 23       	and	r24, r18
 1ea:	88 bb       	out	0x18, r24	; 24
 1ec:	08 95       	ret
 1ee:	41 30       	cpi	r20, 0x01	; 1
 1f0:	59 f4       	brne	.+22     	; 0x208 <DIO_write+0x96>
 1f2:	25 b3       	in	r18, 0x15	; 21
 1f4:	81 e0       	ldi	r24, 0x01	; 1
 1f6:	90 e0       	ldi	r25, 0x00	; 0
 1f8:	02 c0       	rjmp	.+4      	; 0x1fe <DIO_write+0x8c>
 1fa:	88 0f       	add	r24, r24
 1fc:	99 1f       	adc	r25, r25
 1fe:	6a 95       	dec	r22
 200:	e2 f7       	brpl	.-8      	; 0x1fa <DIO_write+0x88>
 202:	82 2b       	or	r24, r18
 204:	85 bb       	out	0x15, r24	; 21
 206:	08 95       	ret
 208:	25 b3       	in	r18, 0x15	; 21
 20a:	81 e0       	ldi	r24, 0x01	; 1
 20c:	90 e0       	ldi	r25, 0x00	; 0
 20e:	02 c0       	rjmp	.+4      	; 0x214 <DIO_write+0xa2>
 210:	88 0f       	add	r24, r24
 212:	99 1f       	adc	r25, r25
 214:	6a 95       	dec	r22
 216:	e2 f7       	brpl	.-8      	; 0x210 <DIO_write+0x9e>
 218:	80 95       	com	r24
 21a:	82 23       	and	r24, r18
 21c:	85 bb       	out	0x15, r24	; 21
 21e:	08 95       	ret
 220:	41 30       	cpi	r20, 0x01	; 1
 222:	59 f4       	brne	.+22     	; 0x23a <DIO_write+0xc8>
 224:	22 b3       	in	r18, 0x12	; 18
 226:	81 e0       	ldi	r24, 0x01	; 1
 228:	90 e0       	ldi	r25, 0x00	; 0
 22a:	02 c0       	rjmp	.+4      	; 0x230 <DIO_write+0xbe>
 22c:	88 0f       	add	r24, r24
 22e:	99 1f       	adc	r25, r25
 230:	6a 95       	dec	r22
 232:	e2 f7       	brpl	.-8      	; 0x22c <DIO_write+0xba>
 234:	82 2b       	or	r24, r18
 236:	82 bb       	out	0x12, r24	; 18
 238:	08 95       	ret
 23a:	22 b3       	in	r18, 0x12	; 18
 23c:	81 e0       	ldi	r24, 0x01	; 1
 23e:	90 e0       	ldi	r25, 0x00	; 0
 240:	02 c0       	rjmp	.+4      	; 0x246 <DIO_write+0xd4>
 242:	88 0f       	add	r24, r24
 244:	99 1f       	adc	r25, r25
 246:	6a 95       	dec	r22
 248:	e2 f7       	brpl	.-8      	; 0x242 <DIO_write+0xd0>
 24a:	80 95       	com	r24
 24c:	82 23       	and	r24, r18
 24e:	82 bb       	out	0x12, r24	; 18
 250:	08 95       	ret

00000252 <DIO_u8read>:
 252:	82 34       	cpi	r24, 0x42	; 66
 254:	e9 f0       	breq	.+58     	; 0x290 <DIO_u8read+0x3e>
 256:	18 f4       	brcc	.+6      	; 0x25e <DIO_u8read+0xc>
 258:	81 34       	cpi	r24, 0x41	; 65
 25a:	31 f0       	breq	.+12     	; 0x268 <DIO_u8read+0x16>
 25c:	55 c0       	rjmp	.+170    	; 0x308 <DIO_u8read+0xb6>
 25e:	83 34       	cpi	r24, 0x43	; 67
 260:	59 f1       	breq	.+86     	; 0x2b8 <DIO_u8read+0x66>
 262:	84 34       	cpi	r24, 0x44	; 68
 264:	e9 f1       	breq	.+122    	; 0x2e0 <DIO_u8read+0x8e>
 266:	50 c0       	rjmp	.+160    	; 0x308 <DIO_u8read+0xb6>
 268:	49 b3       	in	r20, 0x19	; 25
 26a:	81 e0       	ldi	r24, 0x01	; 1
 26c:	90 e0       	ldi	r25, 0x00	; 0
 26e:	9c 01       	movw	r18, r24
 270:	06 2e       	mov	r0, r22
 272:	02 c0       	rjmp	.+4      	; 0x278 <DIO_u8read+0x26>
 274:	22 0f       	add	r18, r18
 276:	33 1f       	adc	r19, r19
 278:	0a 94       	dec	r0
 27a:	e2 f7       	brpl	.-8      	; 0x274 <DIO_u8read+0x22>
 27c:	84 2f       	mov	r24, r20
 27e:	90 e0       	ldi	r25, 0x00	; 0
 280:	82 23       	and	r24, r18
 282:	93 23       	and	r25, r19
 284:	02 c0       	rjmp	.+4      	; 0x28a <DIO_u8read+0x38>
 286:	95 95       	asr	r25
 288:	87 95       	ror	r24
 28a:	6a 95       	dec	r22
 28c:	e2 f7       	brpl	.-8      	; 0x286 <DIO_u8read+0x34>
 28e:	08 95       	ret
 290:	46 b3       	in	r20, 0x16	; 22
 292:	81 e0       	ldi	r24, 0x01	; 1
 294:	90 e0       	ldi	r25, 0x00	; 0
 296:	9c 01       	movw	r18, r24
 298:	06 2e       	mov	r0, r22
 29a:	02 c0       	rjmp	.+4      	; 0x2a0 <DIO_u8read+0x4e>
 29c:	22 0f       	add	r18, r18
 29e:	33 1f       	adc	r19, r19
 2a0:	0a 94       	dec	r0
 2a2:	e2 f7       	brpl	.-8      	; 0x29c <DIO_u8read+0x4a>
 2a4:	84 2f       	mov	r24, r20
 2a6:	90 e0       	ldi	r25, 0x00	; 0
 2a8:	82 23       	and	r24, r18
 2aa:	93 23       	and	r25, r19
 2ac:	02 c0       	rjmp	.+4      	; 0x2b2 <DIO_u8read+0x60>
 2ae:	95 95       	asr	r25
 2b0:	87 95       	ror	r24
 2b2:	6a 95       	dec	r22
 2b4:	e2 f7       	brpl	.-8      	; 0x2ae <DIO_u8read+0x5c>
 2b6:	08 95       	ret
 2b8:	43 b3       	in	r20, 0x13	; 19
 2ba:	81 e0       	ldi	r24, 0x01	; 1
 2bc:	90 e0       	ldi	r25, 0x00	; 0
 2be:	9c 01       	movw	r18, r24
 2c0:	06 2e       	mov	r0, r22
 2c2:	02 c0       	rjmp	.+4      	; 0x2c8 <DIO_u8read+0x76>
 2c4:	22 0f       	add	r18, r18
 2c6:	33 1f       	adc	r19, r19
 2c8:	0a 94       	dec	r0
 2ca:	e2 f7       	brpl	.-8      	; 0x2c4 <DIO_u8read+0x72>
 2cc:	84 2f       	mov	r24, r20
 2ce:	90 e0       	ldi	r25, 0x00	; 0
 2d0:	82 23       	and	r24, r18
 2d2:	93 23       	and	r25, r19
 2d4:	02 c0       	rjmp	.+4      	; 0x2da <DIO_u8read+0x88>
 2d6:	95 95       	asr	r25
 2d8:	87 95       	ror	r24
 2da:	6a 95       	dec	r22
 2dc:	e2 f7       	brpl	.-8      	; 0x2d6 <DIO_u8read+0x84>
 2de:	08 95       	ret
 2e0:	40 b3       	in	r20, 0x10	; 16
 2e2:	81 e0       	ldi	r24, 0x01	; 1
 2e4:	90 e0       	ldi	r25, 0x00	; 0
 2e6:	9c 01       	movw	r18, r24
 2e8:	06 2e       	mov	r0, r22
 2ea:	02 c0       	rjmp	.+4      	; 0x2f0 <DIO_u8read+0x9e>
 2ec:	22 0f       	add	r18, r18
 2ee:	33 1f       	adc	r19, r19
 2f0:	0a 94       	dec	r0
 2f2:	e2 f7       	brpl	.-8      	; 0x2ec <DIO_u8read+0x9a>
 2f4:	84 2f       	mov	r24, r20
 2f6:	90 e0       	ldi	r25, 0x00	; 0
 2f8:	82 23       	and	r24, r18
 2fa:	93 23       	and	r25, r19
 2fc:	02 c0       	rjmp	.+4      	; 0x302 <DIO_u8read+0xb0>
 2fe:	95 95       	asr	r25
 300:	87 95       	ror	r24
 302:	6a 95       	dec	r22
 304:	e2 f7       	brpl	.-8      	; 0x2fe <DIO_u8read+0xac>
 306:	08 95       	ret
 308:	80 e0       	ldi	r24, 0x00	; 0
 30a:	08 95       	ret

0000030c <DIO_write_port>:
 30c:	82 34       	cpi	r24, 0x42	; 66
 30e:	59 f0       	breq	.+22     	; 0x326 <DIO_write_port+0x1a>
 310:	18 f4       	brcc	.+6      	; 0x318 <DIO_write_port+0xc>
 312:	81 34       	cpi	r24, 0x41	; 65
 314:	31 f0       	breq	.+12     	; 0x322 <DIO_write_port+0x16>
 316:	08 95       	ret
 318:	83 34       	cpi	r24, 0x43	; 67
 31a:	39 f0       	breq	.+14     	; 0x32a <DIO_write_port+0x1e>
 31c:	84 34       	cpi	r24, 0x44	; 68
 31e:	39 f0       	breq	.+14     	; 0x32e <DIO_write_port+0x22>
 320:	08 95       	ret
 322:	6b bb       	out	0x1b, r22	; 27
 324:	08 95       	ret
 326:	68 bb       	out	0x18, r22	; 24
 328:	08 95       	ret
 32a:	65 bb       	out	0x15, r22	; 21
 32c:	08 95       	ret
 32e:	62 bb       	out	0x12, r22	; 18
 330:	08 95       	ret

00000332 <DIO_vconnectpullup>:
	}
}

void DIO_vconnectpullup(uint8 portname ,uint8 pinnumber, uint8 connect_pullup)
{
	switch(portname)
 332:	82 34       	cpi	r24, 0x42	; 66
 334:	61 f1       	breq	.+88     	; 0x38e <DIO_vconnectpullup+0x5c>
 336:	18 f4       	brcc	.+6      	; 0x33e <DIO_vconnectpullup+0xc>
 338:	81 34       	cpi	r24, 0x41	; 65
 33a:	41 f0       	breq	.+16     	; 0x34c <DIO_vconnectpullup+0x1a>
 33c:	08 95       	ret
 33e:	83 34       	cpi	r24, 0x43	; 67
 340:	09 f4       	brne	.+2      	; 0x344 <DIO_vconnectpullup+0x12>
 342:	46 c0       	rjmp	.+140    	; 0x3d0 <DIO_vconnectpullup+0x9e>
 344:	84 34       	cpi	r24, 0x44	; 68
 346:	09 f4       	brne	.+2      	; 0x34a <DIO_vconnectpullup+0x18>
 348:	64 c0       	rjmp	.+200    	; 0x412 <__EEPROM_REGION_LENGTH__+0x12>
 34a:	08 95       	ret
	{
		/* Connect or disconnect the pull up resistance to the given pin in port A */
		case 'A':
		if(connect_pullup==1)
 34c:	41 30       	cpi	r20, 0x01	; 1
 34e:	99 f4       	brne	.+38     	; 0x376 <DIO_vconnectpullup+0x44>
		{
			CLR_BIT(SFIOR,PUD);
 350:	80 b7       	in	r24, 0x30	; 48
 352:	8b 7f       	andi	r24, 0xFB	; 251
 354:	80 bf       	out	0x30, r24	; 48
			CLR_BIT(DDRA,pinnumber);
 356:	2a b3       	in	r18, 0x1a	; 26
 358:	81 e0       	ldi	r24, 0x01	; 1
 35a:	90 e0       	ldi	r25, 0x00	; 0
 35c:	02 c0       	rjmp	.+4      	; 0x362 <DIO_vconnectpullup+0x30>
 35e:	88 0f       	add	r24, r24
 360:	99 1f       	adc	r25, r25
 362:	6a 95       	dec	r22
 364:	e2 f7       	brpl	.-8      	; 0x35e <DIO_vconnectpullup+0x2c>
 366:	98 2f       	mov	r25, r24
 368:	90 95       	com	r25
 36a:	92 23       	and	r25, r18
 36c:	9a bb       	out	0x1a, r25	; 26
			SET_BIT(PORTA,pinnumber);
 36e:	9b b3       	in	r25, 0x1b	; 27
 370:	89 2b       	or	r24, r25
 372:	8b bb       	out	0x1b, r24	; 27
 374:	08 95       	ret
		}
		else
		{
			CLR_BIT(PORTA,pinnumber);
 376:	2b b3       	in	r18, 0x1b	; 27
 378:	81 e0       	ldi	r24, 0x01	; 1
 37a:	90 e0       	ldi	r25, 0x00	; 0
 37c:	02 c0       	rjmp	.+4      	; 0x382 <DIO_vconnectpullup+0x50>
 37e:	88 0f       	add	r24, r24
 380:	99 1f       	adc	r25, r25
 382:	6a 95       	dec	r22
 384:	e2 f7       	brpl	.-8      	; 0x37e <DIO_vconnectpullup+0x4c>
 386:	80 95       	com	r24
 388:	82 23       	and	r24, r18
 38a:	8b bb       	out	0x1b, r24	; 27
 38c:	08 95       	ret
		}
		break;
		/* Connect or disconnect the pull up resistance to the given pin in port B */
		case 'B':
		if(connect_pullup==1)
 38e:	41 30       	cpi	r20, 0x01	; 1
 390:	99 f4       	brne	.+38     	; 0x3b8 <DIO_vconnectpullup+0x86>
		{
			CLR_BIT(SFIOR,PUD);
 392:	80 b7       	in	r24, 0x30	; 48
 394:	8b 7f       	andi	r24, 0xFB	; 251
 396:	80 bf       	out	0x30, r24	; 48
			CLR_BIT(DDRB,pinnumber);
 398:	27 b3       	in	r18, 0x17	; 23
 39a:	81 e0       	ldi	r24, 0x01	; 1
 39c:	90 e0       	ldi	r25, 0x00	; 0
 39e:	02 c0       	rjmp	.+4      	; 0x3a4 <DIO_vconnectpullup+0x72>
 3a0:	88 0f       	add	r24, r24
 3a2:	99 1f       	adc	r25, r25
 3a4:	6a 95       	dec	r22
 3a6:	e2 f7       	brpl	.-8      	; 0x3a0 <DIO_vconnectpullup+0x6e>
 3a8:	98 2f       	mov	r25, r24
 3aa:	90 95       	com	r25
 3ac:	92 23       	and	r25, r18
 3ae:	97 bb       	out	0x17, r25	; 23
			SET_BIT(PORTB,pinnumber);
 3b0:	98 b3       	in	r25, 0x18	; 24
 3b2:	89 2b       	or	r24, r25
 3b4:	88 bb       	out	0x18, r24	; 24
 3b6:	08 95       	ret
		}
		else
		{
			CLR_BIT(PORTB,pinnumber);
 3b8:	28 b3       	in	r18, 0x18	; 24
 3ba:	81 e0       	ldi	r24, 0x01	; 1
 3bc:	90 e0       	ldi	r25, 0x00	; 0
 3be:	02 c0       	rjmp	.+4      	; 0x3c4 <DIO_vconnectpullup+0x92>
 3c0:	88 0f       	add	r24, r24
 3c2:	99 1f       	adc	r25, r25
 3c4:	6a 95       	dec	r22
 3c6:	e2 f7       	brpl	.-8      	; 0x3c0 <DIO_vconnectpullup+0x8e>
 3c8:	80 95       	com	r24
 3ca:	82 23       	and	r24, r18
 3cc:	88 bb       	out	0x18, r24	; 24
 3ce:	08 95       	ret
		}
		break;
		/* Connect or disconnect the pull up resistance to the given pin in port C */
		case 'C':
		if(connect_pullup==1)
 3d0:	41 30       	cpi	r20, 0x01	; 1
 3d2:	99 f4       	brne	.+38     	; 0x3fa <DIO_vconnectpullup+0xc8>
		{
			CLR_BIT(SFIOR,PUD);
 3d4:	80 b7       	in	r24, 0x30	; 48
 3d6:	8b 7f       	andi	r24, 0xFB	; 251
 3d8:	80 bf       	out	0x30, r24	; 48
			CLR_BIT(DDRC,pinnumber);
 3da:	24 b3       	in	r18, 0x14	; 20
 3dc:	81 e0       	ldi	r24, 0x01	; 1
 3de:	90 e0       	ldi	r25, 0x00	; 0
 3e0:	02 c0       	rjmp	.+4      	; 0x3e6 <DIO_vconnectpullup+0xb4>
 3e2:	88 0f       	add	r24, r24
 3e4:	99 1f       	adc	r25, r25
 3e6:	6a 95       	dec	r22
 3e8:	e2 f7       	brpl	.-8      	; 0x3e2 <DIO_vconnectpullup+0xb0>
 3ea:	98 2f       	mov	r25, r24
 3ec:	90 95       	com	r25
 3ee:	92 23       	and	r25, r18
 3f0:	94 bb       	out	0x14, r25	; 20
			SET_BIT(PORTC,pinnumber);
 3f2:	95 b3       	in	r25, 0x15	; 21
 3f4:	89 2b       	or	r24, r25
 3f6:	85 bb       	out	0x15, r24	; 21
 3f8:	08 95       	ret
		}
		else
		{
			CLR_BIT(PORTC,pinnumber);
 3fa:	25 b3       	in	r18, 0x15	; 21
 3fc:	81 e0       	ldi	r24, 0x01	; 1
 3fe:	90 e0       	ldi	r25, 0x00	; 0
 400:	02 c0       	rjmp	.+4      	; 0x406 <__EEPROM_REGION_LENGTH__+0x6>
 402:	88 0f       	add	r24, r24
 404:	99 1f       	adc	r25, r25
 406:	6a 95       	dec	r22
 408:	e2 f7       	brpl	.-8      	; 0x402 <__EEPROM_REGION_LENGTH__+0x2>
 40a:	80 95       	com	r24
 40c:	82 23       	and	r24, r18
 40e:	85 bb       	out	0x15, r24	; 21
 410:	08 95       	ret
		}
		break;
		/* Connect or disconnect the pull up resistance to the given pin in port D */
		case 'D':
		if(connect_pullup==1)
 412:	41 30       	cpi	r20, 0x01	; 1
 414:	99 f4       	brne	.+38     	; 0x43c <__EEPROM_REGION_LENGTH__+0x3c>
		{
			CLR_BIT(SFIOR,PUD);
 416:	80 b7       	in	r24, 0x30	; 48
 418:	8b 7f       	andi	r24, 0xFB	; 251
 41a:	80 bf       	out	0x30, r24	; 48
			CLR_BIT(DDRD,pinnumber);
 41c:	21 b3       	in	r18, 0x11	; 17
 41e:	81 e0       	ldi	r24, 0x01	; 1
 420:	90 e0       	ldi	r25, 0x00	; 0
 422:	02 c0       	rjmp	.+4      	; 0x428 <__EEPROM_REGION_LENGTH__+0x28>
 424:	88 0f       	add	r24, r24
 426:	99 1f       	adc	r25, r25
 428:	6a 95       	dec	r22
 42a:	e2 f7       	brpl	.-8      	; 0x424 <__EEPROM_REGION_LENGTH__+0x24>
 42c:	98 2f       	mov	r25, r24
 42e:	90 95       	com	r25
 430:	92 23       	and	r25, r18
 432:	91 bb       	out	0x11, r25	; 17
			SET_BIT(PORTD,pinnumber);
 434:	92 b3       	in	r25, 0x12	; 18
 436:	89 2b       	or	r24, r25
 438:	82 bb       	out	0x12, r24	; 18
 43a:	08 95       	ret
		}
		else
		{
			CLR_BIT(PORTD,pinnumber);
 43c:	22 b3       	in	r18, 0x12	; 18
 43e:	81 e0       	ldi	r24, 0x01	; 1
 440:	90 e0       	ldi	r25, 0x00	; 0
 442:	02 c0       	rjmp	.+4      	; 0x448 <__EEPROM_REGION_LENGTH__+0x48>
 444:	88 0f       	add	r24, r24
 446:	99 1f       	adc	r25, r25
 448:	6a 95       	dec	r22
 44a:	e2 f7       	brpl	.-8      	; 0x444 <__EEPROM_REGION_LENGTH__+0x44>
 44c:	80 95       	com	r24
 44e:	82 23       	and	r24, r18
 450:	82 bb       	out	0x12, r24	; 18
 452:	08 95       	ret

00000454 <Dio_PinSetDirection>:
	return ReturnValue;
}
ReturnValueType Dio_PinSetDirection (PortType port , uint8 PinNumber,PinDirectionType PinDirection)
{
	ReturnValueType  ReturnValue = OK;
	switch (port)
 454:	81 30       	cpi	r24, 0x01	; 1
 456:	31 f1       	breq	.+76     	; 0x4a4 <Dio_PinSetDirection+0x50>
 458:	38 f0       	brcs	.+14     	; 0x468 <Dio_PinSetDirection+0x14>
 45a:	82 30       	cpi	r24, 0x02	; 2
 45c:	09 f4       	brne	.+2      	; 0x460 <Dio_PinSetDirection+0xc>
 45e:	40 c0       	rjmp	.+128    	; 0x4e0 <Dio_PinSetDirection+0x8c>
 460:	83 30       	cpi	r24, 0x03	; 3
 462:	09 f4       	brne	.+2      	; 0x466 <Dio_PinSetDirection+0x12>
 464:	5a c0       	rjmp	.+180    	; 0x51a <Dio_PinSetDirection+0xc6>
 466:	76 c0       	rjmp	.+236    	; 0x554 <Dio_PinSetDirection+0x100>
	{
		case A:
		if (PinDirection == PinInput) CLR_BIT(DDRA,PinNumber);
 468:	41 11       	cpse	r20, r1
 46a:	0d c0       	rjmp	.+26     	; 0x486 <Dio_PinSetDirection+0x32>
 46c:	2a b3       	in	r18, 0x1a	; 26
 46e:	81 e0       	ldi	r24, 0x01	; 1
 470:	90 e0       	ldi	r25, 0x00	; 0
 472:	02 c0       	rjmp	.+4      	; 0x478 <Dio_PinSetDirection+0x24>
 474:	88 0f       	add	r24, r24
 476:	99 1f       	adc	r25, r25
 478:	6a 95       	dec	r22
 47a:	e2 f7       	brpl	.-8      	; 0x474 <Dio_PinSetDirection+0x20>
 47c:	80 95       	com	r24
 47e:	82 23       	and	r24, r18
 480:	8a bb       	out	0x1a, r24	; 26
	asm	volatile ("nop");  
	return ReturnValue;
}
ReturnValueType Dio_PinSetDirection (PortType port , uint8 PinNumber,PinDirectionType PinDirection)
{
	ReturnValueType  ReturnValue = OK;
 482:	81 e0       	ldi	r24, 0x01	; 1
 484:	70 c0       	rjmp	.+224    	; 0x566 <Dio_PinSetDirection+0x112>
	switch (port)
	{
		case A:
		if (PinDirection == PinInput) CLR_BIT(DDRA,PinNumber);
		else if (PinDirection == PinOutput) SET_BIT(DDRA,PinNumber);
 486:	41 30       	cpi	r20, 0x01	; 1
 488:	09 f0       	breq	.+2      	; 0x48c <Dio_PinSetDirection+0x38>
 48a:	66 c0       	rjmp	.+204    	; 0x558 <Dio_PinSetDirection+0x104>
 48c:	2a b3       	in	r18, 0x1a	; 26
 48e:	81 e0       	ldi	r24, 0x01	; 1
 490:	90 e0       	ldi	r25, 0x00	; 0
 492:	02 c0       	rjmp	.+4      	; 0x498 <Dio_PinSetDirection+0x44>
 494:	88 0f       	add	r24, r24
 496:	99 1f       	adc	r25, r25
 498:	6a 95       	dec	r22
 49a:	e2 f7       	brpl	.-8      	; 0x494 <Dio_PinSetDirection+0x40>
 49c:	82 2b       	or	r24, r18
 49e:	8a bb       	out	0x1a, r24	; 26
	asm	volatile ("nop");  
	return ReturnValue;
}
ReturnValueType Dio_PinSetDirection (PortType port , uint8 PinNumber,PinDirectionType PinDirection)
{
	ReturnValueType  ReturnValue = OK;
 4a0:	81 e0       	ldi	r24, 0x01	; 1
 4a2:	61 c0       	rjmp	.+194    	; 0x566 <Dio_PinSetDirection+0x112>
		else if (PinDirection == PinOutput) SET_BIT(DDRA,PinNumber);
		else ReturnValue = NOK ; 
		
		break;
		case B:
		if (PinDirection == PinInput) CLR_BIT(DDRB,PinNumber);
 4a4:	41 11       	cpse	r20, r1
 4a6:	0d c0       	rjmp	.+26     	; 0x4c2 <Dio_PinSetDirection+0x6e>
 4a8:	27 b3       	in	r18, 0x17	; 23
 4aa:	81 e0       	ldi	r24, 0x01	; 1
 4ac:	90 e0       	ldi	r25, 0x00	; 0
 4ae:	02 c0       	rjmp	.+4      	; 0x4b4 <Dio_PinSetDirection+0x60>
 4b0:	88 0f       	add	r24, r24
 4b2:	99 1f       	adc	r25, r25
 4b4:	6a 95       	dec	r22
 4b6:	e2 f7       	brpl	.-8      	; 0x4b0 <Dio_PinSetDirection+0x5c>
 4b8:	80 95       	com	r24
 4ba:	82 23       	and	r24, r18
 4bc:	87 bb       	out	0x17, r24	; 23
	asm	volatile ("nop");  
	return ReturnValue;
}
ReturnValueType Dio_PinSetDirection (PortType port , uint8 PinNumber,PinDirectionType PinDirection)
{
	ReturnValueType  ReturnValue = OK;
 4be:	81 e0       	ldi	r24, 0x01	; 1
 4c0:	52 c0       	rjmp	.+164    	; 0x566 <Dio_PinSetDirection+0x112>
		else ReturnValue = NOK ; 
		
		break;
		case B:
		if (PinDirection == PinInput) CLR_BIT(DDRB,PinNumber);
		else if (PinDirection == PinOutput) SET_BIT(DDRB,PinNumber);
 4c2:	41 30       	cpi	r20, 0x01	; 1
 4c4:	09 f0       	breq	.+2      	; 0x4c8 <Dio_PinSetDirection+0x74>
 4c6:	4a c0       	rjmp	.+148    	; 0x55c <Dio_PinSetDirection+0x108>
 4c8:	27 b3       	in	r18, 0x17	; 23
 4ca:	81 e0       	ldi	r24, 0x01	; 1
 4cc:	90 e0       	ldi	r25, 0x00	; 0
 4ce:	02 c0       	rjmp	.+4      	; 0x4d4 <Dio_PinSetDirection+0x80>
 4d0:	88 0f       	add	r24, r24
 4d2:	99 1f       	adc	r25, r25
 4d4:	6a 95       	dec	r22
 4d6:	e2 f7       	brpl	.-8      	; 0x4d0 <Dio_PinSetDirection+0x7c>
 4d8:	82 2b       	or	r24, r18
 4da:	87 bb       	out	0x17, r24	; 23
	asm	volatile ("nop");  
	return ReturnValue;
}
ReturnValueType Dio_PinSetDirection (PortType port , uint8 PinNumber,PinDirectionType PinDirection)
{
	ReturnValueType  ReturnValue = OK;
 4dc:	81 e0       	ldi	r24, 0x01	; 1
 4de:	43 c0       	rjmp	.+134    	; 0x566 <Dio_PinSetDirection+0x112>
		if (PinDirection == PinInput) CLR_BIT(DDRB,PinNumber);
		else if (PinDirection == PinOutput) SET_BIT(DDRB,PinNumber);
		else ReturnValue = NOK ;
		break;
		case C:
		if (PinDirection == PinInput) CLR_BIT(DDRC,PinNumber);
 4e0:	41 11       	cpse	r20, r1
 4e2:	0d c0       	rjmp	.+26     	; 0x4fe <Dio_PinSetDirection+0xaa>
 4e4:	24 b3       	in	r18, 0x14	; 20
 4e6:	81 e0       	ldi	r24, 0x01	; 1
 4e8:	90 e0       	ldi	r25, 0x00	; 0
 4ea:	02 c0       	rjmp	.+4      	; 0x4f0 <Dio_PinSetDirection+0x9c>
 4ec:	88 0f       	add	r24, r24
 4ee:	99 1f       	adc	r25, r25
 4f0:	6a 95       	dec	r22
 4f2:	e2 f7       	brpl	.-8      	; 0x4ec <Dio_PinSetDirection+0x98>
 4f4:	80 95       	com	r24
 4f6:	82 23       	and	r24, r18
 4f8:	84 bb       	out	0x14, r24	; 20
	asm	volatile ("nop");  
	return ReturnValue;
}
ReturnValueType Dio_PinSetDirection (PortType port , uint8 PinNumber,PinDirectionType PinDirection)
{
	ReturnValueType  ReturnValue = OK;
 4fa:	81 e0       	ldi	r24, 0x01	; 1
 4fc:	34 c0       	rjmp	.+104    	; 0x566 <Dio_PinSetDirection+0x112>
		else if (PinDirection == PinOutput) SET_BIT(DDRB,PinNumber);
		else ReturnValue = NOK ;
		break;
		case C:
		if (PinDirection == PinInput) CLR_BIT(DDRC,PinNumber);
		else if (PinDirection == PinOutput) SET_BIT(DDRC,PinNumber);
 4fe:	41 30       	cpi	r20, 0x01	; 1
 500:	79 f5       	brne	.+94     	; 0x560 <Dio_PinSetDirection+0x10c>
 502:	24 b3       	in	r18, 0x14	; 20
 504:	81 e0       	ldi	r24, 0x01	; 1
 506:	90 e0       	ldi	r25, 0x00	; 0
 508:	02 c0       	rjmp	.+4      	; 0x50e <Dio_PinSetDirection+0xba>
 50a:	88 0f       	add	r24, r24
 50c:	99 1f       	adc	r25, r25
 50e:	6a 95       	dec	r22
 510:	e2 f7       	brpl	.-8      	; 0x50a <Dio_PinSetDirection+0xb6>
 512:	82 2b       	or	r24, r18
 514:	84 bb       	out	0x14, r24	; 20
	asm	volatile ("nop");  
	return ReturnValue;
}
ReturnValueType Dio_PinSetDirection (PortType port , uint8 PinNumber,PinDirectionType PinDirection)
{
	ReturnValueType  ReturnValue = OK;
 516:	81 e0       	ldi	r24, 0x01	; 1
 518:	26 c0       	rjmp	.+76     	; 0x566 <Dio_PinSetDirection+0x112>
		if (PinDirection == PinInput) CLR_BIT(DDRC,PinNumber);
		else if (PinDirection == PinOutput) SET_BIT(DDRC,PinNumber);
		else ReturnValue = NOK ;
		break;
		case D:
		if (PinDirection == PinInput) CLR_BIT(DDRD,PinNumber);
 51a:	41 11       	cpse	r20, r1
 51c:	0d c0       	rjmp	.+26     	; 0x538 <Dio_PinSetDirection+0xe4>
 51e:	21 b3       	in	r18, 0x11	; 17
 520:	81 e0       	ldi	r24, 0x01	; 1
 522:	90 e0       	ldi	r25, 0x00	; 0
 524:	02 c0       	rjmp	.+4      	; 0x52a <Dio_PinSetDirection+0xd6>
 526:	88 0f       	add	r24, r24
 528:	99 1f       	adc	r25, r25
 52a:	6a 95       	dec	r22
 52c:	e2 f7       	brpl	.-8      	; 0x526 <Dio_PinSetDirection+0xd2>
 52e:	80 95       	com	r24
 530:	82 23       	and	r24, r18
 532:	81 bb       	out	0x11, r24	; 17
	asm	volatile ("nop");  
	return ReturnValue;
}
ReturnValueType Dio_PinSetDirection (PortType port , uint8 PinNumber,PinDirectionType PinDirection)
{
	ReturnValueType  ReturnValue = OK;
 534:	81 e0       	ldi	r24, 0x01	; 1
 536:	17 c0       	rjmp	.+46     	; 0x566 <Dio_PinSetDirection+0x112>
		else if (PinDirection == PinOutput) SET_BIT(DDRC,PinNumber);
		else ReturnValue = NOK ;
		break;
		case D:
		if (PinDirection == PinInput) CLR_BIT(DDRD,PinNumber);
		else if (PinDirection == PinOutput) SET_BIT(DDRD,PinNumber);
 538:	41 30       	cpi	r20, 0x01	; 1
 53a:	a1 f4       	brne	.+40     	; 0x564 <Dio_PinSetDirection+0x110>
 53c:	21 b3       	in	r18, 0x11	; 17
 53e:	81 e0       	ldi	r24, 0x01	; 1
 540:	90 e0       	ldi	r25, 0x00	; 0
 542:	02 c0       	rjmp	.+4      	; 0x548 <Dio_PinSetDirection+0xf4>
 544:	88 0f       	add	r24, r24
 546:	99 1f       	adc	r25, r25
 548:	6a 95       	dec	r22
 54a:	e2 f7       	brpl	.-8      	; 0x544 <Dio_PinSetDirection+0xf0>
 54c:	82 2b       	or	r24, r18
 54e:	81 bb       	out	0x11, r24	; 17
	asm	volatile ("nop");  
	return ReturnValue;
}
ReturnValueType Dio_PinSetDirection (PortType port , uint8 PinNumber,PinDirectionType PinDirection)
{
	ReturnValueType  ReturnValue = OK;
 550:	81 e0       	ldi	r24, 0x01	; 1
 552:	09 c0       	rjmp	.+18     	; 0x566 <Dio_PinSetDirection+0x112>
		if (PinDirection == PinInput) CLR_BIT(DDRD,PinNumber);
		else if (PinDirection == PinOutput) SET_BIT(DDRD,PinNumber);
		else ReturnValue = NOK ;
		break;
		default:
		ReturnValue = NOK ;
 554:	80 e0       	ldi	r24, 0x00	; 0
 556:	07 c0       	rjmp	.+14     	; 0x566 <Dio_PinSetDirection+0x112>
	switch (port)
	{
		case A:
		if (PinDirection == PinInput) CLR_BIT(DDRA,PinNumber);
		else if (PinDirection == PinOutput) SET_BIT(DDRA,PinNumber);
		else ReturnValue = NOK ; 
 558:	80 e0       	ldi	r24, 0x00	; 0
 55a:	05 c0       	rjmp	.+10     	; 0x566 <Dio_PinSetDirection+0x112>
		
		break;
		case B:
		if (PinDirection == PinInput) CLR_BIT(DDRB,PinNumber);
		else if (PinDirection == PinOutput) SET_BIT(DDRB,PinNumber);
		else ReturnValue = NOK ;
 55c:	80 e0       	ldi	r24, 0x00	; 0
 55e:	03 c0       	rjmp	.+6      	; 0x566 <Dio_PinSetDirection+0x112>
		break;
		case C:
		if (PinDirection == PinInput) CLR_BIT(DDRC,PinNumber);
		else if (PinDirection == PinOutput) SET_BIT(DDRC,PinNumber);
		else ReturnValue = NOK ;
 560:	80 e0       	ldi	r24, 0x00	; 0
 562:	01 c0       	rjmp	.+2      	; 0x566 <Dio_PinSetDirection+0x112>
		break;
		case D:
		if (PinDirection == PinInput) CLR_BIT(DDRD,PinNumber);
		else if (PinDirection == PinOutput) SET_BIT(DDRD,PinNumber);
		else ReturnValue = NOK ;
 564:	80 e0       	ldi	r24, 0x00	; 0
		break;
		default:
		ReturnValue = NOK ;
		break;
	}
	asm	volatile ("nop"); 
 566:	00 00       	nop
	return ReturnValue;
}
 568:	08 95       	ret

0000056a <EEPROM_vReadBlockFromAddress>:
	/* Return data from data register */
	return EEDR;
}

void EEPROM_vReadBlockFromAddress(const uint16 uiAddress, uint8* dist,const uint16 size)
{
 56a:	dc 01       	movw	r26, r24
	/* Wait for completion of previous write */
	while (((EECR & (1 << EEWE))>>EEWE)==1)
 56c:	e1 99       	sbic	0x1c, 1	; 28
 56e:	fe cf       	rjmp	.-4      	; 0x56c <EEPROM_vReadBlockFromAddress+0x2>
 570:	20 e0       	ldi	r18, 0x00	; 0
 572:	30 e0       	ldi	r19, 0x00	; 0
 574:	0f c0       	rjmp	.+30     	; 0x594 <EEPROM_vReadBlockFromAddress+0x2a>
	uint16 counter = 0;//the counter of bytes that are read

	while (counter < size) //loop until move all bytes to the given array
	{
		/* Set up address register */
		EEAR = uiAddress + counter;
 576:	f9 01       	movw	r30, r18
 578:	ea 0f       	add	r30, r26
 57a:	fb 1f       	adc	r31, r27
 57c:	ff bb       	out	0x1f, r31	; 31
 57e:	ee bb       	out	0x1e, r30	; 30
		/* Start EEPROM read by writing EERE */
		EECR |= (1 << EERE);
 580:	9c b3       	in	r25, 0x1c	; 28
 582:	91 60       	ori	r25, 0x01	; 1
 584:	9c bb       	out	0x1c, r25	; 28
		/* move data from data register to the array */
		*(dist + counter) = EEDR;
 586:	fb 01       	movw	r30, r22
 588:	e2 0f       	add	r30, r18
 58a:	f3 1f       	adc	r31, r19
 58c:	9d b3       	in	r25, 0x1d	; 29
 58e:	90 83       	st	Z, r25

		counter++;//increase the bytes counter
 590:	2f 5f       	subi	r18, 0xFF	; 255
 592:	3f 4f       	sbci	r19, 0xFF	; 255
	while (((EECR & (1 << EEWE))>>EEWE)==1)
	;

	uint16 counter = 0;//the counter of bytes that are read

	while (counter < size) //loop until move all bytes to the given array
 594:	24 17       	cp	r18, r20
 596:	35 07       	cpc	r19, r21
 598:	70 f3       	brcs	.-36     	; 0x576 <EEPROM_vReadBlockFromAddress+0xc>
		/* move data from data register to the array */
		*(dist + counter) = EEDR;

		counter++;//increase the bytes counter
	}
}
 59a:	08 95       	ret

0000059c <EEPROM_vWriteByteToAddress>:

void EEPROM_vWriteByteToAddress(const uint16 uiAddress, const uint8 uiData)
{

	/* Wait for completion of previous write process*/
	while ( ( (EECR & (1 << EEWE) ) >>EEWE ) == 1)
 59c:	e1 99       	sbic	0x1c, 1	; 28
 59e:	fe cf       	rjmp	.-4      	; 0x59c <EEPROM_vWriteByteToAddress>
	;
	/* Set up address register */
	EEAR = uiAddress;
 5a0:	9f bb       	out	0x1f, r25	; 31
 5a2:	8e bb       	out	0x1e, r24	; 30

	/* Read the byte in the address of EEAR */
	EECR |= (1 << EERE);
 5a4:	8c b3       	in	r24, 0x1c	; 28
 5a6:	81 60       	ori	r24, 0x01	; 1
 5a8:	8c bb       	out	0x1c, r24	; 28
	if (EEDR != uiData)//compare the value read to the value to be written
 5aa:	8d b3       	in	r24, 0x1d	; 29
 5ac:	86 17       	cp	r24, r22
 5ae:	39 f0       	breq	.+14     	; 0x5be <EEPROM_vWriteByteToAddress+0x22>
	{//if they are not equal then write the data 
		EEDR = uiData;//move the data to EEDR
 5b0:	6d bb       	out	0x1d, r22	; 29

		/* Write logical one to EEMWE */
		EECR |= (1 << EEMWE);
 5b2:	8c b3       	in	r24, 0x1c	; 28
 5b4:	84 60       	ori	r24, 0x04	; 4
 5b6:	8c bb       	out	0x1c, r24	; 28
		/* Start EEPROM write by setting EEWE */
		EECR |= (1 << EEWE);
 5b8:	8c b3       	in	r24, 0x1c	; 28
 5ba:	82 60       	ori	r24, 0x02	; 2
 5bc:	8c bb       	out	0x1c, r24	; 28
 5be:	08 95       	ret

000005c0 <EEPROM_vWriteBlockToAddress>:
	}

}

void EEPROM_vWriteBlockToAddress(const uint16 uiAddress, const uint8* uiData,const uint16 size)
{
 5c0:	cf 93       	push	r28
 5c2:	df 93       	push	r29
 5c4:	dc 01       	movw	r26, r24
 5c6:	ea 01       	movw	r28, r20
	uint16 counter = 0;//Bytes write counter
 5c8:	20 e0       	ldi	r18, 0x00	; 0
 5ca:	30 e0       	ldi	r19, 0x00	; 0
	while (counter < size)
 5cc:	1a c0       	rjmp	.+52     	; 0x602 <EEPROM_vWriteBlockToAddress+0x42>
	{
		/* Wait for completion of previous write process*/
		while (( (EECR & (1 << EEWE) ) >>EEWE ) == 1)
 5ce:	e1 99       	sbic	0x1c, 1	; 28
 5d0:	fe cf       	rjmp	.-4      	; 0x5ce <EEPROM_vWriteBlockToAddress+0xe>
		;
		/* Set up address register */
		EEAR = uiAddress + counter;
 5d2:	c9 01       	movw	r24, r18
 5d4:	8a 0f       	add	r24, r26
 5d6:	9b 1f       	adc	r25, r27
 5d8:	9f bb       	out	0x1f, r25	; 31
 5da:	8e bb       	out	0x1e, r24	; 30

		/* Read the byte in the address of EEAR */
		EECR |= (1 << EERE);
 5dc:	9c b3       	in	r25, 0x1c	; 28
 5de:	91 60       	ori	r25, 0x01	; 1
 5e0:	9c bb       	out	0x1c, r25	; 28
		if (EEDR != (*(uiData + counter)))//compare the value read to the value to be written
 5e2:	5d b3       	in	r21, 0x1d	; 29
 5e4:	fb 01       	movw	r30, r22
 5e6:	e2 0f       	add	r30, r18
 5e8:	f3 1f       	adc	r31, r19
 5ea:	90 81       	ld	r25, Z
 5ec:	59 17       	cp	r21, r25
 5ee:	39 f0       	breq	.+14     	; 0x5fe <EEPROM_vWriteBlockToAddress+0x3e>
		{//if they are not equal then write the data 
			EEDR = *(uiData + counter);//move the data to EEDR
 5f0:	9d bb       	out	0x1d, r25	; 29

			/* Write logical one to EEMWE */
			EECR |= (1 << EEMWE);
 5f2:	9c b3       	in	r25, 0x1c	; 28
 5f4:	94 60       	ori	r25, 0x04	; 4
 5f6:	9c bb       	out	0x1c, r25	; 28
			/* Start EEPROM write by setting EEWE */
			EECR |= (1 << EEWE);
 5f8:	9c b3       	in	r25, 0x1c	; 28
 5fa:	92 60       	ori	r25, 0x02	; 2
 5fc:	9c bb       	out	0x1c, r25	; 28
		}
		else
		{

		}
		counter++;//increase bytes counter
 5fe:	2f 5f       	subi	r18, 0xFF	; 255
 600:	3f 4f       	sbci	r19, 0xFF	; 255
}

void EEPROM_vWriteBlockToAddress(const uint16 uiAddress, const uint8* uiData,const uint16 size)
{
	uint16 counter = 0;//Bytes write counter
	while (counter < size)
 602:	2c 17       	cp	r18, r28
 604:	3d 07       	cpc	r19, r29
 606:	18 f3       	brcs	.-58     	; 0x5ce <EEPROM_vWriteBlockToAddress+0xe>
		{

		}
		counter++;//increase bytes counter
	}
}
 608:	df 91       	pop	r29
 60a:	cf 91       	pop	r28
 60c:	08 95       	ret

0000060e <keypad_vInit>:

#include "keypad_driver.h"
void keypad_vInit(void)
{
	/* Initialize first four bits in keypad as output pins */
	DIO_vsetPINDir(KEYPAD_PORT,KEYPAD_FIRST_PIN,1);
 60e:	41 e0       	ldi	r20, 0x01	; 1
 610:	60 e0       	ldi	r22, 0x00	; 0
 612:	83 e4       	ldi	r24, 0x43	; 67
 614:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir(KEYPAD_PORT,KEYPAD_SECOND_PIN,1);
 618:	41 e0       	ldi	r20, 0x01	; 1
 61a:	61 e0       	ldi	r22, 0x01	; 1
 61c:	83 e4       	ldi	r24, 0x43	; 67
 61e:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir(KEYPAD_PORT,KEYPAD_THIRD_PIN,1);
 622:	41 e0       	ldi	r20, 0x01	; 1
 624:	62 e0       	ldi	r22, 0x02	; 2
 626:	83 e4       	ldi	r24, 0x43	; 67
 628:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir(KEYPAD_PORT,KEYPAD_FOURTH_PIN,1);
 62c:	41 e0       	ldi	r20, 0x01	; 1
 62e:	63 e0       	ldi	r22, 0x03	; 3
 630:	83 e4       	ldi	r24, 0x43	; 67
 632:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	/******************************************************/
	/* initalize second four bits in keypad as input pins */
	DIO_vsetPINDir(KEYPAD_PORT,KEYPAD_FIFTH_PIN,0);
 636:	40 e0       	ldi	r20, 0x00	; 0
 638:	64 e0       	ldi	r22, 0x04	; 4
 63a:	83 e4       	ldi	r24, 0x43	; 67
 63c:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir(KEYPAD_PORT,KEYPAD_SIXTH_PIN,0);
 640:	40 e0       	ldi	r20, 0x00	; 0
 642:	65 e0       	ldi	r22, 0x05	; 5
 644:	83 e4       	ldi	r24, 0x43	; 67
 646:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir(KEYPAD_PORT,KEYPAD_SEVENTH_PIN,0);
 64a:	40 e0       	ldi	r20, 0x00	; 0
 64c:	66 e0       	ldi	r22, 0x06	; 6
 64e:	83 e4       	ldi	r24, 0x43	; 67
 650:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir(KEYPAD_PORT,KEYPAD_EIGHTH_PIN,0);
 654:	40 e0       	ldi	r20, 0x00	; 0
 656:	67 e0       	ldi	r22, 0x07	; 7
 658:	83 e4       	ldi	r24, 0x43	; 67
 65a:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	/*****************************************************/
	/*connect pull up resistance to the input pins*/
	DIO_vconnectpullup(KEYPAD_PORT,KEYPAD_FIFTH_PIN,1);
 65e:	41 e0       	ldi	r20, 0x01	; 1
 660:	64 e0       	ldi	r22, 0x04	; 4
 662:	83 e4       	ldi	r24, 0x43	; 67
 664:	0e 94 99 01 	call	0x332	; 0x332 <DIO_vconnectpullup>
	DIO_vconnectpullup(KEYPAD_PORT,KEYPAD_SIXTH_PIN,1);
 668:	41 e0       	ldi	r20, 0x01	; 1
 66a:	65 e0       	ldi	r22, 0x05	; 5
 66c:	83 e4       	ldi	r24, 0x43	; 67
 66e:	0e 94 99 01 	call	0x332	; 0x332 <DIO_vconnectpullup>
	DIO_vconnectpullup(KEYPAD_PORT,KEYPAD_SEVENTH_PIN,1);
 672:	41 e0       	ldi	r20, 0x01	; 1
 674:	66 e0       	ldi	r22, 0x06	; 6
 676:	83 e4       	ldi	r24, 0x43	; 67
 678:	0e 94 99 01 	call	0x332	; 0x332 <DIO_vconnectpullup>
	DIO_vconnectpullup(KEYPAD_PORT,KEYPAD_EIGHTH_PIN,1);
 67c:	41 e0       	ldi	r20, 0x01	; 1
 67e:	67 e0       	ldi	r22, 0x07	; 7
 680:	83 e4       	ldi	r24, 0x43	; 67
 682:	0e 94 99 01 	call	0x332	; 0x332 <DIO_vconnectpullup>
 686:	08 95       	ret

00000688 <keypad_u8check_press>:
	/****************************************************/
}
uint8 keypad_u8check_press(void)
{
 688:	ff 92       	push	r15
 68a:	0f 93       	push	r16
 68c:	1f 93       	push	r17
 68e:	cf 93       	push	r28
 690:	df 93       	push	r29
 692:	cd b7       	in	r28, 0x3d	; 61
 694:	de b7       	in	r29, 0x3e	; 62
 696:	60 97       	sbiw	r28, 0x10	; 16
 698:	0f b6       	in	r0, 0x3f	; 63
 69a:	f8 94       	cli
 69c:	de bf       	out	0x3e, r29	; 62
 69e:	0f be       	out	0x3f, r0	; 63
 6a0:	cd bf       	out	0x3d, r28	; 61
	uint8 arr[4][4]={{'7','8','9','/'},{'4','5','6','*'},{'1','2','3','-'},{'A','0','=','+'}}; //keypad buttons
 6a2:	80 e1       	ldi	r24, 0x10	; 16
 6a4:	e0 e6       	ldi	r30, 0x60	; 96
 6a6:	f0 e0       	ldi	r31, 0x00	; 0
 6a8:	de 01       	movw	r26, r28
 6aa:	11 96       	adiw	r26, 0x01	; 1
 6ac:	01 90       	ld	r0, Z+
 6ae:	0d 92       	st	X+, r0
 6b0:	8a 95       	dec	r24
 6b2:	e1 f7       	brne	.-8      	; 0x6ac <keypad_u8check_press+0x24>
	uint8 row; //which indicate the given output  pin
	uint8 coloumn; //which indicate the given input pin
	uint8 key_pressed_indicator; //the variable  which contain the key pressed
	
	uint8 returnval=NOT_PRESSED; //the variable contain the value which will be returned which will be key pressed or not pressed in case of no key pressed
 6b4:	ff 24       	eor	r15, r15
 6b6:	fa 94       	dec	r15
	for(row=0;row<4;row++)
 6b8:	00 e0       	ldi	r16, 0x00	; 0
 6ba:	3c c0       	rjmp	.+120    	; 0x734 <keypad_u8check_press+0xac>
	{
		/*stop the work of keypad firstly*/
		DIO_write(KEYPAD_PORT,KEYPAD_FIRST_PIN,1);
 6bc:	41 e0       	ldi	r20, 0x01	; 1
 6be:	60 e0       	ldi	r22, 0x00	; 0
 6c0:	83 e4       	ldi	r24, 0x43	; 67
 6c2:	0e 94 b9 00 	call	0x172	; 0x172 <DIO_write>
		DIO_write(KEYPAD_PORT,KEYPAD_SECOND_PIN,1);
 6c6:	41 e0       	ldi	r20, 0x01	; 1
 6c8:	61 e0       	ldi	r22, 0x01	; 1
 6ca:	83 e4       	ldi	r24, 0x43	; 67
 6cc:	0e 94 b9 00 	call	0x172	; 0x172 <DIO_write>
		DIO_write(KEYPAD_PORT,KEYPAD_THIRD_PIN,1);
 6d0:	41 e0       	ldi	r20, 0x01	; 1
 6d2:	62 e0       	ldi	r22, 0x02	; 2
 6d4:	83 e4       	ldi	r24, 0x43	; 67
 6d6:	0e 94 b9 00 	call	0x172	; 0x172 <DIO_write>
		DIO_write(KEYPAD_PORT,KEYPAD_FOURTH_PIN,1);
 6da:	41 e0       	ldi	r20, 0x01	; 1
 6dc:	63 e0       	ldi	r22, 0x03	; 3
 6de:	83 e4       	ldi	r24, 0x43	; 67
 6e0:	0e 94 b9 00 	call	0x172	; 0x172 <DIO_write>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 6e4:	8f e1       	ldi	r24, 0x1F	; 31
 6e6:	9e e4       	ldi	r25, 0x4E	; 78
 6e8:	01 97       	sbiw	r24, 0x01	; 1
 6ea:	f1 f7       	brne	.-4      	; 0x6e8 <keypad_u8check_press+0x60>
 6ec:	00 c0       	rjmp	.+0      	; 0x6ee <keypad_u8check_press+0x66>
 6ee:	00 00       	nop
		/*************************************/
		_delay_ms(20); 
		DIO_write(KEYPAD_PORT,row,0);//write 0 to the first pin in keypad (output pin from MC)
 6f0:	40 e0       	ldi	r20, 0x00	; 0
 6f2:	60 2f       	mov	r22, r16
 6f4:	83 e4       	ldi	r24, 0x43	; 67
 6f6:	0e 94 b9 00 	call	0x172	; 0x172 <DIO_write>
		
		for(coloumn=0;coloumn<4;coloumn++)
 6fa:	10 e0       	ldi	r17, 0x00	; 0
 6fc:	18 c0       	rjmp	.+48     	; 0x72e <keypad_u8check_press+0xa6>
		{
			key_pressed_indicator=DIO_u8read(KEYPAD_PORT,(coloumn+4)); // read the input pins of MC which connected to keypad
 6fe:	64 e0       	ldi	r22, 0x04	; 4
 700:	61 0f       	add	r22, r17
 702:	83 e4       	ldi	r24, 0x43	; 67
 704:	0e 94 29 01 	call	0x252	; 0x252 <DIO_u8read>
			if(key_pressed_indicator==0)// will be 0 only if any key pressed
 708:	81 11       	cpse	r24, r1
 70a:	10 c0       	rjmp	.+32     	; 0x72c <keypad_u8check_press+0xa4>
			{
				returnval=arr[row][coloumn]; //put the selected pressed key to the retrurnval
 70c:	e0 2f       	mov	r30, r16
 70e:	f0 e0       	ldi	r31, 0x00	; 0
 710:	ee 0f       	add	r30, r30
 712:	ff 1f       	adc	r31, r31
 714:	ee 0f       	add	r30, r30
 716:	ff 1f       	adc	r31, r31
 718:	81 e0       	ldi	r24, 0x01	; 1
 71a:	90 e0       	ldi	r25, 0x00	; 0
 71c:	8c 0f       	add	r24, r28
 71e:	9d 1f       	adc	r25, r29
 720:	e8 0f       	add	r30, r24
 722:	f9 1f       	adc	r31, r25
 724:	e1 0f       	add	r30, r17
 726:	f1 1d       	adc	r31, r1
 728:	f0 80       	ld	r15, Z
				break; // break from the loop
 72a:	03 c0       	rjmp	.+6      	; 0x732 <keypad_u8check_press+0xaa>
		DIO_write(KEYPAD_PORT,KEYPAD_FOURTH_PIN,1);
		/*************************************/
		_delay_ms(20); 
		DIO_write(KEYPAD_PORT,row,0);//write 0 to the first pin in keypad (output pin from MC)
		
		for(coloumn=0;coloumn<4;coloumn++)
 72c:	1f 5f       	subi	r17, 0xFF	; 255
 72e:	14 30       	cpi	r17, 0x04	; 4
 730:	30 f3       	brcs	.-52     	; 0x6fe <keypad_u8check_press+0x76>
	uint8 row; //which indicate the given output  pin
	uint8 coloumn; //which indicate the given input pin
	uint8 key_pressed_indicator; //the variable  which contain the key pressed
	
	uint8 returnval=NOT_PRESSED; //the variable contain the value which will be returned which will be key pressed or not pressed in case of no key pressed
	for(row=0;row<4;row++)
 732:	0f 5f       	subi	r16, 0xFF	; 255
 734:	04 30       	cpi	r16, 0x04	; 4
 736:	10 f2       	brcs	.-124    	; 0x6bc <keypad_u8check_press+0x34>
				break; // break from the loop
			}
		}
	}
	return returnval ; //return the pressed key in case of key pressed or return 0xff in case of no key pressed
 738:	8f 2d       	mov	r24, r15
 73a:	60 96       	adiw	r28, 0x10	; 16
 73c:	0f b6       	in	r0, 0x3f	; 63
 73e:	f8 94       	cli
 740:	de bf       	out	0x3e, r29	; 62
 742:	0f be       	out	0x3f, r0	; 63
 744:	cd bf       	out	0x3d, r28	; 61
 746:	df 91       	pop	r29
 748:	cf 91       	pop	r28
 74a:	1f 91       	pop	r17
 74c:	0f 91       	pop	r16
 74e:	ff 90       	pop	r15
 750:	08 95       	ret

00000752 <send_falling_edge>:


static void send_falling_edge(void)
{
	/* to enable printing the sent character to LCD ,we should send send falling edge to the lcd*/ 
	DIO_write(LCD_CONTROL_PORT,LCD_EN_PIN,1); // set enable pin to one
 752:	41 e0       	ldi	r20, 0x01	; 1
 754:	60 e0       	ldi	r22, 0x00	; 0
 756:	82 e4       	ldi	r24, 0x42	; 66
 758:	0e 94 b9 00 	call	0x172	; 0x172 <DIO_write>
 75c:	8f ec       	ldi	r24, 0xCF	; 207
 75e:	97 e0       	ldi	r25, 0x07	; 7
 760:	01 97       	sbiw	r24, 0x01	; 1
 762:	f1 f7       	brne	.-4      	; 0x760 <send_falling_edge+0xe>
 764:	00 c0       	rjmp	.+0      	; 0x766 <send_falling_edge+0x14>
 766:	00 00       	nop
	_delay_ms(2); //period of high
	DIO_write(LCD_CONTROL_PORT,LCD_EN_PIN,0); // clear enable pin 
 768:	40 e0       	ldi	r20, 0x00	; 0
 76a:	60 e0       	ldi	r22, 0x00	; 0
 76c:	82 e4       	ldi	r24, 0x42	; 66
 76e:	0e 94 b9 00 	call	0x172	; 0x172 <DIO_write>
 772:	8f ec       	ldi	r24, 0xCF	; 207
 774:	97 e0       	ldi	r25, 0x07	; 7
 776:	01 97       	sbiw	r24, 0x01	; 1
 778:	f1 f7       	brne	.-4      	; 0x776 <send_falling_edge+0x24>
 77a:	00 c0       	rjmp	.+0      	; 0x77c <send_falling_edge+0x2a>
 77c:	00 00       	nop
 77e:	08 95       	ret

00000780 <LCD_vSend_cmd>:
	_delay_ms(2); // period of low
}
void LCD_vSend_cmd(uint8 cmd)
{
	#if defined eight_bits_mode //depend on pre-defined configurations which exist in lcd_config.h
	DIO_write_port(LCD_PORT,cmd); //send the command to LCD
 780:	68 2f       	mov	r22, r24
 782:	81 e4       	ldi	r24, 0x41	; 65
 784:	0e 94 86 01 	call	0x30c	; 0x30c <DIO_write_port>
	DIO_write(LCD_CONTROL_PORT,LCD_RS_PIN,0); //enable LCD to receive command 
 788:	40 e0       	ldi	r20, 0x00	; 0
 78a:	61 e0       	ldi	r22, 0x01	; 1
 78c:	82 e4       	ldi	r24, 0x42	; 66
 78e:	0e 94 b9 00 	call	0x172	; 0x172 <DIO_write>
	send_falling_edge(); //send falling edge
 792:	0e 94 a9 03 	call	0x752	; 0x752 <send_falling_edge>
 796:	08 95       	ret

00000798 <LCD_vInit>:

void LCD_vInit(void)
{
	#if defined eight_bits_mode //depend on pre-defined configurations which exist in lcd_config.h
	/* set LCD pins as output pins in case of 8 bit LCD*/
	DIO_vsetPINDir(LCD_PORT,LCD_FIRST_PIN,1);
 798:	41 e0       	ldi	r20, 0x01	; 1
 79a:	60 e0       	ldi	r22, 0x00	; 0
 79c:	81 e4       	ldi	r24, 0x41	; 65
 79e:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir(LCD_PORT,LCD_SECOND_PIN,1);
 7a2:	41 e0       	ldi	r20, 0x01	; 1
 7a4:	61 e0       	ldi	r22, 0x01	; 1
 7a6:	81 e4       	ldi	r24, 0x41	; 65
 7a8:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir(LCD_PORT,LCD_THIRD_PIN,1);
 7ac:	41 e0       	ldi	r20, 0x01	; 1
 7ae:	62 e0       	ldi	r22, 0x02	; 2
 7b0:	81 e4       	ldi	r24, 0x41	; 65
 7b2:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir(LCD_PORT,LCD_FOURTH_PIN,1);
 7b6:	41 e0       	ldi	r20, 0x01	; 1
 7b8:	63 e0       	ldi	r22, 0x03	; 3
 7ba:	81 e4       	ldi	r24, 0x41	; 65
 7bc:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir(LCD_PORT,LCD_FIFTH_PIN,1);
 7c0:	41 e0       	ldi	r20, 0x01	; 1
 7c2:	64 e0       	ldi	r22, 0x04	; 4
 7c4:	81 e4       	ldi	r24, 0x41	; 65
 7c6:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir(LCD_PORT,LCD_SIXTH_PIN,1);
 7ca:	41 e0       	ldi	r20, 0x01	; 1
 7cc:	65 e0       	ldi	r22, 0x05	; 5
 7ce:	81 e4       	ldi	r24, 0x41	; 65
 7d0:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir(LCD_PORT,LCD_SEVENTH_PIN,1);
 7d4:	41 e0       	ldi	r20, 0x01	; 1
 7d6:	66 e0       	ldi	r22, 0x06	; 6
 7d8:	81 e4       	ldi	r24, 0x41	; 65
 7da:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir(LCD_PORT,LCD_EIGHTH_PIN,1);
 7de:	41 e0       	ldi	r20, 0x01	; 1
 7e0:	67 e0       	ldi	r22, 0x07	; 7
 7e2:	81 e4       	ldi	r24, 0x41	; 65
 7e4:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	/*****************************/
	/* set LCD control pins as output pins in case of 8 bit LCD */
	DIO_vsetPINDir(LCD_CONTROL_PORT,LCD_EN_PIN,1);
 7e8:	41 e0       	ldi	r20, 0x01	; 1
 7ea:	60 e0       	ldi	r22, 0x00	; 0
 7ec:	82 e4       	ldi	r24, 0x42	; 66
 7ee:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir(LCD_CONTROL_PORT,LCD_RW_PIN,1);
 7f2:	41 e0       	ldi	r20, 0x01	; 1
 7f4:	62 e0       	ldi	r22, 0x02	; 2
 7f6:	82 e4       	ldi	r24, 0x42	; 66
 7f8:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir(LCD_CONTROL_PORT,LCD_RS_PIN,1);
 7fc:	41 e0       	ldi	r20, 0x01	; 1
 7fe:	61 e0       	ldi	r22, 0x01	; 1
 800:	82 e4       	ldi	r24, 0x42	; 66
 802:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	/*****************************/
	DIO_write(LCD_CONTROL_PORT,LCD_RW_PIN,0); // enable write to LCD 
 806:	40 e0       	ldi	r20, 0x00	; 0
 808:	62 e0       	ldi	r22, 0x02	; 2
 80a:	82 e4       	ldi	r24, 0x42	; 66
 80c:	0e 94 b9 00 	call	0x172	; 0x172 <DIO_write>
	LCD_vSend_cmd(EIGHT_BIT_MODE); //enable 8 bit LCD Mode 
 810:	88 e3       	ldi	r24, 0x38	; 56
 812:	0e 94 c0 03 	call	0x780	; 0x780 <LCD_vSend_cmd>
	LCD_vSend_cmd(CLR_SCREEN); // CLR LCD screen 
 816:	81 e0       	ldi	r24, 0x01	; 1
 818:	0e 94 c0 03 	call	0x780	; 0x780 <LCD_vSend_cmd>
	LCD_vSend_cmd(DISPLAY_ON_CURSOR_ON); // enable cursor and display on 
 81c:	8e e0       	ldi	r24, 0x0E	; 14
 81e:	0e 94 c0 03 	call	0x780	; 0x780 <LCD_vSend_cmd>
 822:	8f e0       	ldi	r24, 0x0F	; 15
 824:	97 e2       	ldi	r25, 0x27	; 39
 826:	01 97       	sbiw	r24, 0x01	; 1
 828:	f1 f7       	brne	.-4      	; 0x826 <__DATA_REGION_LENGTH__+0x26>
 82a:	00 c0       	rjmp	.+0      	; 0x82c <__DATA_REGION_LENGTH__+0x2c>
 82c:	00 00       	nop
 82e:	08 95       	ret

00000830 <LCD_vSend_char>:
	
}
void LCD_vSend_char(uint8 data)
{
	#if defined eight_bits_mode //depend on pre-defined configurations which exist in lcd_config.h
	DIO_write_port(LCD_PORT,data); //send the data to LCD
 830:	68 2f       	mov	r22, r24
 832:	81 e4       	ldi	r24, 0x41	; 65
 834:	0e 94 86 01 	call	0x30c	; 0x30c <DIO_write_port>
	DIO_write(LCD_CONTROL_PORT,LCD_RS_PIN,1); //enable LCD to receive data
 838:	41 e0       	ldi	r20, 0x01	; 1
 83a:	61 e0       	ldi	r22, 0x01	; 1
 83c:	82 e4       	ldi	r24, 0x42	; 66
 83e:	0e 94 b9 00 	call	0x172	; 0x172 <DIO_write>
	send_falling_edge(); //send falling edge
 842:	0e 94 a9 03 	call	0x752	; 0x752 <send_falling_edge>
 846:	08 95       	ret

00000848 <LCD_vSend_string>:
	/******************************************/
	#endif
}

void LCD_vSend_string(char *data)
{
 848:	cf 93       	push	r28
 84a:	df 93       	push	r29
 84c:	ec 01       	movw	r28, r24
	while((*data)!=0) //keep in the loop until the end of the string 
 84e:	03 c0       	rjmp	.+6      	; 0x856 <LCD_vSend_string+0xe>
	{
		LCD_vSend_char(*data); // print the characters of the string 
 850:	0e 94 18 04 	call	0x830	; 0x830 <LCD_vSend_char>
		data++; // make the pointer points to the next character
 854:	21 96       	adiw	r28, 0x01	; 1
	#endif
}

void LCD_vSend_string(char *data)
{
	while((*data)!=0) //keep in the loop until the end of the string 
 856:	88 81       	ld	r24, Y
 858:	81 11       	cpse	r24, r1
 85a:	fa cf       	rjmp	.-12     	; 0x850 <LCD_vSend_string+0x8>
	{
		LCD_vSend_char(*data); // print the characters of the string 
		data++; // make the pointer points to the next character
	}
}
 85c:	df 91       	pop	r29
 85e:	cf 91       	pop	r28
 860:	08 95       	ret

00000862 <LCD_clearscreen>:

void LCD_clearscreen(void)
{
	LCD_vSend_cmd(CLR_SCREEN); // clear the screen
 862:	81 e0       	ldi	r24, 0x01	; 1
 864:	0e 94 c0 03 	call	0x780	; 0x780 <LCD_vSend_cmd>
 868:	08 95       	ret

0000086a <LCD_movecursor>:
	{
		data=0x80;
	}
	/********************************************/
	/*set the postion of cursor depend on the selected row and coloumn*/
	if(row==1)
 86a:	81 30       	cpi	r24, 0x01	; 1
 86c:	19 f4       	brne	.+6      	; 0x874 <LCD_movecursor+0xa>
	{
		data=0x80+coloumn-1 ;
 86e:	8f e7       	ldi	r24, 0x7F	; 127
 870:	86 0f       	add	r24, r22
 872:	06 c0       	rjmp	.+12     	; 0x880 <LCD_movecursor+0x16>
	}
	else if (row==2)
 874:	82 30       	cpi	r24, 0x02	; 2
 876:	19 f4       	brne	.+6      	; 0x87e <LCD_movecursor+0x14>
	{
		data=0xc0+coloumn-1;
 878:	8f eb       	ldi	r24, 0xBF	; 191
 87a:	86 0f       	add	r24, r22
 87c:	01 c0       	rjmp	.+2      	; 0x880 <LCD_movecursor+0x16>
 87e:	80 e8       	ldi	r24, 0x80	; 128
	}
	/**************************************/
	
	LCD_vSend_cmd(data); //set the position  of the cursor
 880:	0e 94 c0 03 	call	0x780	; 0x780 <LCD_vSend_cmd>
 884:	08 95       	ret

00000886 <timer1_init>:
uint8 key_pressed;
uint8 login_mode;
uint8 flag;
void timer1_init()              
{
	TCCR1B = (1<<CS10) | (1<<CS12);
 886:	85 e0       	ldi	r24, 0x05	; 5
 888:	8e bd       	out	0x2e, r24	; 46
	TCCR1A = 0X00;
 88a:	1f bc       	out	0x2f, r1	; 47
	//OCR1A = 1562;
	TCNT1 = 63974;
 88c:	86 ee       	ldi	r24, 0xE6	; 230
 88e:	99 ef       	ldi	r25, 0xF9	; 249
 890:	9d bd       	out	0x2d, r25	; 45
 892:	8c bd       	out	0x2c, r24	; 44
	TIMSK = (1<<TOIE1);
 894:	84 e0       	ldi	r24, 0x04	; 4
 896:	89 bf       	out	0x39, r24	; 57
 898:	08 95       	ret

0000089a <timer1_stop>:
	//sei();
}
void timer1_stop()         
{
	TCCR1B &= ~(1<<CS10);
 89a:	8e b5       	in	r24, 0x2e	; 46
 89c:	8e 7f       	andi	r24, 0xFE	; 254
 89e:	8e bd       	out	0x2e, r24	; 46
	TCCR1B &= ~(1<<CS12);
 8a0:	8e b5       	in	r24, 0x2e	; 46
 8a2:	8b 7f       	andi	r24, 0xFB	; 251
 8a4:	8e bd       	out	0x2e, r24	; 46
 8a6:	08 95       	ret

000008a8 <ComparePass>:
}

uint8 ComparePass(const uint8* pass1,const uint8* pass2,const uint8 size)
{
 8a8:	dc 01       	movw	r26, r24
	uint8 pin_counter=0;
 8aa:	90 e0       	ldi	r25, 0x00	; 0
	uint8 ret_value = TRUE;
	while (pin_counter<size)
 8ac:	0d c0       	rjmp	.+26     	; 0x8c8 <ComparePass+0x20>
	{
		if (*(pass1+pin_counter)!=*(pass2+pin_counter))
 8ae:	29 2f       	mov	r18, r25
 8b0:	30 e0       	ldi	r19, 0x00	; 0
 8b2:	fd 01       	movw	r30, r26
 8b4:	e2 0f       	add	r30, r18
 8b6:	f3 1f       	adc	r31, r19
 8b8:	50 81       	ld	r21, Z
 8ba:	fb 01       	movw	r30, r22
 8bc:	e2 0f       	add	r30, r18
 8be:	f3 1f       	adc	r31, r19
 8c0:	20 81       	ld	r18, Z
 8c2:	52 13       	cpse	r21, r18
 8c4:	05 c0       	rjmp	.+10     	; 0x8d0 <ComparePass+0x28>
		{
			ret_value= FALSE;
			break;
		}
		pin_counter++;
 8c6:	9f 5f       	subi	r25, 0xFF	; 255

uint8 ComparePass(const uint8* pass1,const uint8* pass2,const uint8 size)
{
	uint8 pin_counter=0;
	uint8 ret_value = TRUE;
	while (pin_counter<size)
 8c8:	94 17       	cp	r25, r20
 8ca:	88 f3       	brcs	.-30     	; 0x8ae <ComparePass+0x6>
}

uint8 ComparePass(const uint8* pass1,const uint8* pass2,const uint8 size)
{
	uint8 pin_counter=0;
	uint8 ret_value = TRUE;
 8cc:	81 e0       	ldi	r24, 0x01	; 1
 8ce:	08 95       	ret
	while (pin_counter<size)
	{
		if (*(pass1+pin_counter)!=*(pass2+pin_counter))
		{
			ret_value= FALSE;
 8d0:	80 e0       	ldi	r24, 0x00	; 0
			break;
		}
		pin_counter++;
	}
	return ret_value;
}
 8d2:	08 95       	ret

000008d4 <Enter_Pass>:

void Enter_Pass()
{
 8d4:	1f 93       	push	r17
 8d6:	cf 93       	push	r28
 8d8:	df 93       	push	r29
 8da:	cd b7       	in	r28, 0x3d	; 61
 8dc:	de b7       	in	r29, 0x3e	; 62
 8de:	28 97       	sbiw	r28, 0x08	; 8
 8e0:	0f b6       	in	r0, 0x3f	; 63
 8e2:	f8 94       	cli
 8e4:	de bf       	out	0x3e, r29	; 62
 8e6:	0f be       	out	0x3f, r0	; 63
 8e8:	cd bf       	out	0x3d, r28	; 61
	key_pressed = NOT_PRESSED;
 8ea:	8f ef       	ldi	r24, 0xFF	; 255
 8ec:	80 93 ac 00 	sts	0x00AC, r24	; 0x8000ac <key_pressed>
	uint8 pass_counter=0;
	uint8 pass[PASS_SIZE]={NOT_STORED,NOT_STORED,NOT_STORED,NOT_STORED};
 8f0:	89 83       	std	Y+1, r24	; 0x01
 8f2:	8a 83       	std	Y+2, r24	; 0x02
 8f4:	8b 83       	std	Y+3, r24	; 0x03
 8f6:	8c 83       	std	Y+4, r24	; 0x04
	uint8 stored_pass[PASS_SIZE]={NOT_STORED,NOT_STORED,NOT_STORED,NOT_STORED};
 8f8:	8d 83       	std	Y+5, r24	; 0x05
 8fa:	8e 83       	std	Y+6, r24	; 0x06
 8fc:	8f 83       	std	Y+7, r24	; 0x07
 8fe:	88 87       	std	Y+8, r24	; 0x08
	
	while(login_mode!=ADMIN)// while admin enters wrong password
 900:	7a c0       	rjmp	.+244    	; 0x9f6 <Enter_Pass+0x122>
	{
		key_pressed = NOT_PRESSED;
 902:	8f ef       	ldi	r24, 0xFF	; 255
 904:	80 93 ac 00 	sts	0x00AC, r24	; 0x8000ac <key_pressed>
		LCD_clearscreen();
 908:	0e 94 31 04 	call	0x862	; 0x862 <LCD_clearscreen>
		LCD_vSend_string("Enter Pass:");
 90c:	80 e7       	ldi	r24, 0x70	; 112
 90e:	90 e0       	ldi	r25, 0x00	; 0
 910:	0e 94 24 04 	call	0x848	; 0x848 <LCD_vSend_string>
 914:	8f e4       	ldi	r24, 0x4F	; 79
 916:	93 ec       	ldi	r25, 0xC3	; 195
 918:	01 97       	sbiw	r24, 0x01	; 1
 91a:	f1 f7       	brne	.-4      	; 0x918 <Enter_Pass+0x44>
 91c:	00 c0       	rjmp	.+0      	; 0x91e <Enter_Pass+0x4a>
 91e:	00 00       	nop
		_delay_ms(50);
		pass_counter=0;
 920:	10 e0       	ldi	r17, 0x00	; 0
		while(pass_counter<PASS_SIZE)
 922:	53 c0       	rjmp	.+166    	; 0x9ca <Enter_Pass+0xf6>
		{
			while (key_pressed == NOT_PRESSED)
			{
				key_pressed = keypad_u8check_press();
 924:	0e 94 44 03 	call	0x688	; 0x688 <keypad_u8check_press>
 928:	80 93 ac 00 	sts	0x00AC, r24	; 0x8000ac <key_pressed>
		LCD_vSend_string("Enter Pass:");
		_delay_ms(50);
		pass_counter=0;
		while(pass_counter<PASS_SIZE)
		{
			while (key_pressed == NOT_PRESSED)
 92c:	80 91 ac 00 	lds	r24, 0x00AC	; 0x8000ac <key_pressed>
 930:	8f 3f       	cpi	r24, 0xFF	; 255
 932:	c1 f3       	breq	.-16     	; 0x924 <Enter_Pass+0x50>
			{
				key_pressed = keypad_u8check_press();
			}
			pass[pass_counter]=key_pressed;
 934:	e1 e0       	ldi	r30, 0x01	; 1
 936:	f0 e0       	ldi	r31, 0x00	; 0
 938:	ec 0f       	add	r30, r28
 93a:	fd 1f       	adc	r31, r29
 93c:	e1 0f       	add	r30, r17
 93e:	f1 1d       	adc	r31, r1
 940:	80 83       	st	Z, r24
			LCD_vSend_char(key_pressed);
 942:	0e 94 18 04 	call	0x830	; 0x830 <LCD_vSend_char>
 946:	8f e1       	ldi	r24, 0x1F	; 31
 948:	9e e4       	ldi	r25, 0x4E	; 78
 94a:	01 97       	sbiw	r24, 0x01	; 1
 94c:	f1 f7       	brne	.-4      	; 0x94a <Enter_Pass+0x76>
 94e:	00 c0       	rjmp	.+0      	; 0x950 <Enter_Pass+0x7c>
 950:	00 00       	nop
			_delay_ms(CHARACTER_PREVIEW_TIME);
			LCD_movecursor(1,12+pass_counter);
 952:	6c e0       	ldi	r22, 0x0C	; 12
 954:	61 0f       	add	r22, r17
 956:	81 e0       	ldi	r24, 0x01	; 1
 958:	0e 94 35 04 	call	0x86a	; 0x86a <LCD_movecursor>
			LCD_vSend_char(PASSWORD_SYMBOL);
 95c:	8a e2       	ldi	r24, 0x2A	; 42
 95e:	0e 94 18 04 	call	0x830	; 0x830 <LCD_vSend_char>
 962:	8f e1       	ldi	r24, 0x1F	; 31
 964:	9e e4       	ldi	r25, 0x4E	; 78
 966:	01 97       	sbiw	r24, 0x01	; 1
 968:	f1 f7       	brne	.-4      	; 0x966 <Enter_Pass+0x92>
 96a:	00 c0       	rjmp	.+0      	; 0x96c <Enter_Pass+0x98>
 96c:	00 00       	nop
			_delay_ms(20);
			pass_counter++;
 96e:	1f 5f       	subi	r17, 0xFF	; 255
			key_pressed = NOT_PRESSED;
 970:	8f ef       	ldi	r24, 0xFF	; 255
 972:	80 93 ac 00 	sts	0x00AC, r24	; 0x8000ac <key_pressed>
			EEPROM_vReadBlockFromAddress(EEPROM_ADMIN_ADDRESS,stored_pass,PASS_SIZE);
 976:	44 e0       	ldi	r20, 0x04	; 4
 978:	50 e0       	ldi	r21, 0x00	; 0
 97a:	be 01       	movw	r22, r28
 97c:	6b 5f       	subi	r22, 0xFB	; 251
 97e:	7f 4f       	sbci	r23, 0xFF	; 255
 980:	82 e0       	ldi	r24, 0x02	; 2
 982:	91 e0       	ldi	r25, 0x01	; 1
 984:	0e 94 b5 02 	call	0x56a	; 0x56a <EEPROM_vReadBlockFromAddress>
			/*compare passwords*/
			if ((ComparePass(pass,stored_pass,pass_counter)) == TRUE)  // correct pass
 988:	41 2f       	mov	r20, r17
 98a:	be 01       	movw	r22, r28
 98c:	6b 5f       	subi	r22, 0xFB	; 251
 98e:	7f 4f       	sbci	r23, 0xFF	; 255
 990:	ce 01       	movw	r24, r28
 992:	01 96       	adiw	r24, 0x01	; 1
 994:	0e 94 54 04 	call	0x8a8	; 0x8a8 <ComparePass>
 998:	81 30       	cpi	r24, 0x01	; 1
 99a:	19 f4       	brne	.+6      	; 0x9a2 <Enter_Pass+0xce>
			{
				login_mode = ADMIN;
 99c:	80 93 ab 00 	sts	0x00AB, r24	; 0x8000ab <login_mode>
 9a0:	14 c0       	rjmp	.+40     	; 0x9ca <Enter_Pass+0xf6>
			}
			else                                                   // wrong pass
			{
				login_mode = NO_MODE;
 9a2:	10 92 ab 00 	sts	0x00AB, r1	; 0x8000ab <login_mode>
				LCD_clearscreen();
 9a6:	0e 94 31 04 	call	0x862	; 0x862 <LCD_clearscreen>
				LCD_vSend_string("Wrong Pass");
 9aa:	8c e7       	ldi	r24, 0x7C	; 124
 9ac:	90 e0       	ldi	r25, 0x00	; 0
 9ae:	0e 94 24 04 	call	0x848	; 0x848 <LCD_vSend_string>
 9b2:	9f ef       	ldi	r25, 0xFF	; 255
 9b4:	24 e3       	ldi	r18, 0x34	; 52
 9b6:	8c e0       	ldi	r24, 0x0C	; 12
 9b8:	91 50       	subi	r25, 0x01	; 1
 9ba:	20 40       	sbci	r18, 0x00	; 0
 9bc:	80 40       	sbci	r24, 0x00	; 0
 9be:	e1 f7       	brne	.-8      	; 0x9b8 <Enter_Pass+0xe4>
 9c0:	00 c0       	rjmp	.+0      	; 0x9c2 <Enter_Pass+0xee>
 9c2:	00 00       	nop
				_delay_ms(1000);
				LCD_clearscreen();
 9c4:	0e 94 31 04 	call	0x862	; 0x862 <LCD_clearscreen>
				break;
 9c8:	03 c0       	rjmp	.+6      	; 0x9d0 <Enter_Pass+0xfc>
		key_pressed = NOT_PRESSED;
		LCD_clearscreen();
		LCD_vSend_string("Enter Pass:");
		_delay_ms(50);
		pass_counter=0;
		while(pass_counter<PASS_SIZE)
 9ca:	14 30       	cpi	r17, 0x04	; 4
 9cc:	08 f4       	brcc	.+2      	; 0x9d0 <Enter_Pass+0xfc>
 9ce:	ae cf       	rjmp	.-164    	; 0x92c <Enter_Pass+0x58>
				_delay_ms(1000);
				LCD_clearscreen();
				break;
			}
		}
		if (login_mode==ADMIN)
 9d0:	80 91 ab 00 	lds	r24, 0x00AB	; 0x8000ab <login_mode>
 9d4:	81 30       	cpi	r24, 0x01	; 1
 9d6:	79 f4       	brne	.+30     	; 0x9f6 <Enter_Pass+0x122>
		{
			LCD_clearscreen();
 9d8:	0e 94 31 04 	call	0x862	; 0x862 <LCD_clearscreen>
			LCD_vSend_string("correct pass");
 9dc:	87 e8       	ldi	r24, 0x87	; 135
 9de:	90 e0       	ldi	r25, 0x00	; 0
 9e0:	0e 94 24 04 	call	0x848	; 0x848 <LCD_vSend_string>
 9e4:	9f e7       	ldi	r25, 0x7F	; 127
 9e6:	2a e1       	ldi	r18, 0x1A	; 26
 9e8:	86 e0       	ldi	r24, 0x06	; 6
 9ea:	91 50       	subi	r25, 0x01	; 1
 9ec:	20 40       	sbci	r18, 0x00	; 0
 9ee:	80 40       	sbci	r24, 0x00	; 0
 9f0:	e1 f7       	brne	.-8      	; 0x9ea <Enter_Pass+0x116>
 9f2:	00 c0       	rjmp	.+0      	; 0x9f4 <Enter_Pass+0x120>
 9f4:	00 00       	nop
	key_pressed = NOT_PRESSED;
	uint8 pass_counter=0;
	uint8 pass[PASS_SIZE]={NOT_STORED,NOT_STORED,NOT_STORED,NOT_STORED};
	uint8 stored_pass[PASS_SIZE]={NOT_STORED,NOT_STORED,NOT_STORED,NOT_STORED};
	
	while(login_mode!=ADMIN)// while admin enters wrong password
 9f6:	80 91 ab 00 	lds	r24, 0x00AB	; 0x8000ab <login_mode>
 9fa:	81 30       	cpi	r24, 0x01	; 1
 9fc:	09 f0       	breq	.+2      	; 0xa00 <Enter_Pass+0x12c>
 9fe:	81 cf       	rjmp	.-254    	; 0x902 <Enter_Pass+0x2e>
			LCD_vSend_string("correct pass");
			_delay_ms(500);
		}
	}
	
}
 a00:	28 96       	adiw	r28, 0x08	; 8
 a02:	0f b6       	in	r0, 0x3f	; 63
 a04:	f8 94       	cli
 a06:	de bf       	out	0x3e, r29	; 62
 a08:	0f be       	out	0x3f, r0	; 63
 a0a:	cd bf       	out	0x3d, r28	; 61
 a0c:	df 91       	pop	r29
 a0e:	cf 91       	pop	r28
 a10:	1f 91       	pop	r17
 a12:	08 95       	ret

00000a14 <Set_Pass>:

void Set_Pass()
{
 a14:	1f 93       	push	r17
 a16:	cf 93       	push	r28
 a18:	df 93       	push	r29
 a1a:	00 d0       	rcall	.+0      	; 0xa1c <Set_Pass+0x8>
 a1c:	00 d0       	rcall	.+0      	; 0xa1e <Set_Pass+0xa>
 a1e:	cd b7       	in	r28, 0x3d	; 61
 a20:	de b7       	in	r29, 0x3e	; 62
	TCNT1=63974;
 a22:	86 ee       	ldi	r24, 0xE6	; 230
 a24:	99 ef       	ldi	r25, 0xF9	; 249
 a26:	9d bd       	out	0x2d, r25	; 45
 a28:	8c bd       	out	0x2c, r24	; 44
	LCD_clearscreen();
 a2a:	0e 94 31 04 	call	0x862	; 0x862 <LCD_clearscreen>
	//enter programming mode
	LCD_vSend_string("Set pass:");
 a2e:	84 e9       	ldi	r24, 0x94	; 148
 a30:	90 e0       	ldi	r25, 0x00	; 0
 a32:	0e 94 24 04 	call	0x848	; 0x848 <LCD_vSend_string>
	uint8 pass_counter=0;
	uint8 pass[PASS_SIZE]={NOT_STORED,NOT_STORED,NOT_STORED,NOT_STORED};
 a36:	8f ef       	ldi	r24, 0xFF	; 255
 a38:	89 83       	std	Y+1, r24	; 0x01
 a3a:	8a 83       	std	Y+2, r24	; 0x02
 a3c:	8b 83       	std	Y+3, r24	; 0x03
 a3e:	8c 83       	std	Y+4, r24	; 0x04
{
	TCNT1=63974;
	LCD_clearscreen();
	//enter programming mode
	LCD_vSend_string("Set pass:");
	uint8 pass_counter=0;
 a40:	10 e0       	ldi	r17, 0x00	; 0
	uint8 pass[PASS_SIZE]={NOT_STORED,NOT_STORED,NOT_STORED,NOT_STORED};
	while (pass_counter<PASS_SIZE)
 a42:	2a c0       	rjmp	.+84     	; 0xa98 <Set_Pass+0x84>
	{
		key_pressed = NOT_PRESSED;
 a44:	8f ef       	ldi	r24, 0xFF	; 255
 a46:	80 93 ac 00 	sts	0x00AC, r24	; 0x8000ac <key_pressed>
		while (key_pressed == NOT_PRESSED)
 a4a:	04 c0       	rjmp	.+8      	; 0xa54 <Set_Pass+0x40>
		{
			key_pressed = keypad_u8check_press();
 a4c:	0e 94 44 03 	call	0x688	; 0x688 <keypad_u8check_press>
 a50:	80 93 ac 00 	sts	0x00AC, r24	; 0x8000ac <key_pressed>
	uint8 pass_counter=0;
	uint8 pass[PASS_SIZE]={NOT_STORED,NOT_STORED,NOT_STORED,NOT_STORED};
	while (pass_counter<PASS_SIZE)
	{
		key_pressed = NOT_PRESSED;
		while (key_pressed == NOT_PRESSED)
 a54:	80 91 ac 00 	lds	r24, 0x00AC	; 0x8000ac <key_pressed>
 a58:	8f 3f       	cpi	r24, 0xFF	; 255
 a5a:	c1 f3       	breq	.-16     	; 0xa4c <Set_Pass+0x38>
		{
			key_pressed = keypad_u8check_press();
		}
		pass[pass_counter]=key_pressed;
 a5c:	e1 e0       	ldi	r30, 0x01	; 1
 a5e:	f0 e0       	ldi	r31, 0x00	; 0
 a60:	ec 0f       	add	r30, r28
 a62:	fd 1f       	adc	r31, r29
 a64:	e1 0f       	add	r30, r17
 a66:	f1 1d       	adc	r31, r1
 a68:	80 83       	st	Z, r24
		LCD_vSend_char(key_pressed);
 a6a:	0e 94 18 04 	call	0x830	; 0x830 <LCD_vSend_char>
 a6e:	8f e1       	ldi	r24, 0x1F	; 31
 a70:	9e e4       	ldi	r25, 0x4E	; 78
 a72:	01 97       	sbiw	r24, 0x01	; 1
 a74:	f1 f7       	brne	.-4      	; 0xa72 <Set_Pass+0x5e>
 a76:	00 c0       	rjmp	.+0      	; 0xa78 <Set_Pass+0x64>
 a78:	00 00       	nop
		_delay_ms(CHARACTER_PREVIEW_TIME);
		LCD_movecursor(1,10+pass_counter);
 a7a:	6a e0       	ldi	r22, 0x0A	; 10
 a7c:	61 0f       	add	r22, r17
 a7e:	81 e0       	ldi	r24, 0x01	; 1
 a80:	0e 94 35 04 	call	0x86a	; 0x86a <LCD_movecursor>
		LCD_vSend_char(PASSWORD_SYMBOL);
 a84:	8a e2       	ldi	r24, 0x2A	; 42
 a86:	0e 94 18 04 	call	0x830	; 0x830 <LCD_vSend_char>
 a8a:	8f e4       	ldi	r24, 0x4F	; 79
 a8c:	93 ec       	ldi	r25, 0xC3	; 195
 a8e:	01 97       	sbiw	r24, 0x01	; 1
 a90:	f1 f7       	brne	.-4      	; 0xa8e <Set_Pass+0x7a>
 a92:	00 c0       	rjmp	.+0      	; 0xa94 <Set_Pass+0x80>
 a94:	00 00       	nop
		_delay_ms(50);
		pass_counter++;
 a96:	1f 5f       	subi	r17, 0xFF	; 255
	LCD_clearscreen();
	//enter programming mode
	LCD_vSend_string("Set pass:");
	uint8 pass_counter=0;
	uint8 pass[PASS_SIZE]={NOT_STORED,NOT_STORED,NOT_STORED,NOT_STORED};
	while (pass_counter<PASS_SIZE)
 a98:	14 30       	cpi	r17, 0x04	; 4
 a9a:	a0 f2       	brcs	.-88     	; 0xa44 <Set_Pass+0x30>
		LCD_movecursor(1,10+pass_counter);
		LCD_vSend_char(PASSWORD_SYMBOL);
		_delay_ms(50);
		pass_counter++;
	}
	EEPROM_vWriteBlockToAddress(EEPROM_ADMIN_ADDRESS,pass,PASS_SIZE);
 a9c:	44 e0       	ldi	r20, 0x04	; 4
 a9e:	50 e0       	ldi	r21, 0x00	; 0
 aa0:	be 01       	movw	r22, r28
 aa2:	6f 5f       	subi	r22, 0xFF	; 255
 aa4:	7f 4f       	sbci	r23, 0xFF	; 255
 aa6:	82 e0       	ldi	r24, 0x02	; 2
 aa8:	91 e0       	ldi	r25, 0x01	; 1
 aaa:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <EEPROM_vWriteBlockToAddress>
	EEPROM_vWriteByteToAddress(ADMIN_PASS_STATUS_ADDRESS,PASS_SET);
 aae:	61 e0       	ldi	r22, 0x01	; 1
 ab0:	80 e0       	ldi	r24, 0x00	; 0
 ab2:	91 e0       	ldi	r25, 0x01	; 1
 ab4:	0e 94 ce 02 	call	0x59c	; 0x59c <EEPROM_vWriteByteToAddress>
	LCD_clearscreen();
 ab8:	0e 94 31 04 	call	0x862	; 0x862 <LCD_clearscreen>
	LCD_vSend_string("Pass Saved");
 abc:	8e e9       	ldi	r24, 0x9E	; 158
 abe:	90 e0       	ldi	r25, 0x00	; 0
 ac0:	0e 94 24 04 	call	0x848	; 0x848 <LCD_vSend_string>
 ac4:	9f e7       	ldi	r25, 0x7F	; 127
 ac6:	2a e1       	ldi	r18, 0x1A	; 26
 ac8:	86 e0       	ldi	r24, 0x06	; 6
 aca:	91 50       	subi	r25, 0x01	; 1
 acc:	20 40       	sbci	r18, 0x00	; 0
 ace:	80 40       	sbci	r24, 0x00	; 0
 ad0:	e1 f7       	brne	.-8      	; 0xaca <Set_Pass+0xb6>
 ad2:	00 c0       	rjmp	.+0      	; 0xad4 <Set_Pass+0xc0>
 ad4:	00 00       	nop
	_delay_ms(500);
	LCD_clearscreen();
 ad6:	0e 94 31 04 	call	0x862	; 0x862 <LCD_clearscreen>
}
 ada:	0f 90       	pop	r0
 adc:	0f 90       	pop	r0
 ade:	0f 90       	pop	r0
 ae0:	0f 90       	pop	r0
 ae2:	df 91       	pop	r29
 ae4:	cf 91       	pop	r28
 ae6:	1f 91       	pop	r17
 ae8:	08 95       	ret

00000aea <main>:

int main(void)
{
	Dio_PinSetDirection(D,2,PinInput);
 aea:	40 e0       	ldi	r20, 0x00	; 0
 aec:	62 e0       	ldi	r22, 0x02	; 2
 aee:	83 e0       	ldi	r24, 0x03	; 3
 af0:	0e 94 2a 02 	call	0x454	; 0x454 <Dio_PinSetDirection>
	Dio_PinSetDirection(D,3,PinInput);
 af4:	40 e0       	ldi	r20, 0x00	; 0
 af6:	63 e0       	ldi	r22, 0x03	; 3
 af8:	83 e0       	ldi	r24, 0x03	; 3
 afa:	0e 94 2a 02 	call	0x454	; 0x454 <Dio_PinSetDirection>
	
	login_mode = NO_MODE; //Store the current user mode admin or guest or not logged in
 afe:	10 92 ab 00 	sts	0x00AB, r1	; 0x8000ab <login_mode>
	key_pressed = NOT_PRESSED;//
 b02:	8f ef       	ldi	r24, 0xFF	; 255
 b04:	80 93 ac 00 	sts	0x00AC, r24	; 0x8000ac <key_pressed>
	/*****************  INITIALIZE  ***********************/
	LCD_vInit();
 b08:	0e 94 cc 03 	call	0x798	; 0x798 <LCD_vInit>
	keypad_vInit();
 b0c:	0e 94 07 03 	call	0x60e	; 0x60e <keypad_vInit>
	
	GICR=1<<INT0 | 1<<INT1 | 1<<INT2;
 b10:	80 ee       	ldi	r24, 0xE0	; 224
 b12:	8b bf       	out	0x3b, r24	; 59
	MCUCR|= 1<<ISC01 | 1<<ISC11 | 1<<ISC10;
 b14:	85 b7       	in	r24, 0x35	; 53
 b16:	8e 60       	ori	r24, 0x0E	; 14
 b18:	85 bf       	out	0x35, r24	; 53
	MCUCSR|=1<<ISC2;
 b1a:	84 b7       	in	r24, 0x34	; 52
 b1c:	80 64       	ori	r24, 0x40	; 64
 b1e:	84 bf       	out	0x34, r24	; 52
	sei();
 b20:	78 94       	sei
	flag=0;
 b22:	10 92 aa 00 	sts	0x00AA, r1	; 0x8000aa <__data_end>
 b26:	ff cf       	rjmp	.-2      	; 0xb26 <main+0x3c>

00000b28 <__vector_1>:
	
	{
	}
}
ISR(INT0_vect)           //on falling
{
 b28:	1f 92       	push	r1
 b2a:	0f 92       	push	r0
 b2c:	0f b6       	in	r0, 0x3f	; 63
 b2e:	0f 92       	push	r0
 b30:	11 24       	eor	r1, r1
 b32:	2f 93       	push	r18
 b34:	3f 93       	push	r19
 b36:	4f 93       	push	r20
 b38:	5f 93       	push	r21
 b3a:	6f 93       	push	r22
 b3c:	7f 93       	push	r23
 b3e:	8f 93       	push	r24
 b40:	9f 93       	push	r25
 b42:	af 93       	push	r26
 b44:	bf 93       	push	r27
 b46:	ef 93       	push	r30
 b48:	ff 93       	push	r31
	sei();
 b4a:	78 94       	sei
	flag=1;
 b4c:	81 e0       	ldi	r24, 0x01	; 1
 b4e:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__data_end>
	timer1_init();
 b52:	0e 94 43 04 	call	0x886	; 0x886 <timer1_init>
}
 b56:	ff 91       	pop	r31
 b58:	ef 91       	pop	r30
 b5a:	bf 91       	pop	r27
 b5c:	af 91       	pop	r26
 b5e:	9f 91       	pop	r25
 b60:	8f 91       	pop	r24
 b62:	7f 91       	pop	r23
 b64:	6f 91       	pop	r22
 b66:	5f 91       	pop	r21
 b68:	4f 91       	pop	r20
 b6a:	3f 91       	pop	r19
 b6c:	2f 91       	pop	r18
 b6e:	0f 90       	pop	r0
 b70:	0f be       	out	0x3f, r0	; 63
 b72:	0f 90       	pop	r0
 b74:	1f 90       	pop	r1
 b76:	18 95       	reti

00000b78 <__vector_2>:
ISR(INT1_vect)         //on rising
{
 b78:	1f 92       	push	r1
 b7a:	0f 92       	push	r0
 b7c:	0f b6       	in	r0, 0x3f	; 63
 b7e:	0f 92       	push	r0
 b80:	11 24       	eor	r1, r1
 b82:	2f 93       	push	r18
 b84:	3f 93       	push	r19
 b86:	4f 93       	push	r20
 b88:	5f 93       	push	r21
 b8a:	6f 93       	push	r22
 b8c:	7f 93       	push	r23
 b8e:	8f 93       	push	r24
 b90:	9f 93       	push	r25
 b92:	af 93       	push	r26
 b94:	bf 93       	push	r27
 b96:	ef 93       	push	r30
 b98:	ff 93       	push	r31
	//exit programming mode
	sei();
 b9a:	78 94       	sei
	timer1_stop();
 b9c:	0e 94 4d 04 	call	0x89a	; 0x89a <timer1_stop>
	LCD_clearscreen();
 ba0:	0e 94 31 04 	call	0x862	; 0x862 <LCD_clearscreen>
	LCD_movecursor(1,1);
 ba4:	61 e0       	ldi	r22, 0x01	; 1
 ba6:	81 e0       	ldi	r24, 0x01	; 1
 ba8:	0e 94 35 04 	call	0x86a	; 0x86a <LCD_movecursor>
	Enter_Pass();
 bac:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <Enter_Pass>
}
 bb0:	ff 91       	pop	r31
 bb2:	ef 91       	pop	r30
 bb4:	bf 91       	pop	r27
 bb6:	af 91       	pop	r26
 bb8:	9f 91       	pop	r25
 bba:	8f 91       	pop	r24
 bbc:	7f 91       	pop	r23
 bbe:	6f 91       	pop	r22
 bc0:	5f 91       	pop	r21
 bc2:	4f 91       	pop	r20
 bc4:	3f 91       	pop	r19
 bc6:	2f 91       	pop	r18
 bc8:	0f 90       	pop	r0
 bca:	0f be       	out	0x3f, r0	; 63
 bcc:	0f 90       	pop	r0
 bce:	1f 90       	pop	r1
 bd0:	18 95       	reti

00000bd2 <__vector_9>:
ISR(TIMER1_OVF_vect)
{
 bd2:	1f 92       	push	r1
 bd4:	0f 92       	push	r0
 bd6:	0f b6       	in	r0, 0x3f	; 63
 bd8:	0f 92       	push	r0
 bda:	11 24       	eor	r1, r1
 bdc:	2f 93       	push	r18
 bde:	3f 93       	push	r19
 be0:	4f 93       	push	r20
 be2:	5f 93       	push	r21
 be4:	6f 93       	push	r22
 be6:	7f 93       	push	r23
 be8:	8f 93       	push	r24
 bea:	9f 93       	push	r25
 bec:	af 93       	push	r26
 bee:	bf 93       	push	r27
 bf0:	ef 93       	push	r30
 bf2:	ff 93       	push	r31
	sei();
 bf4:	78 94       	sei
	if (flag==1)
 bf6:	80 91 aa 00 	lds	r24, 0x00AA	; 0x8000aa <__data_end>
 bfa:	81 30       	cpi	r24, 0x01	; 1
 bfc:	21 f4       	brne	.+8      	; 0xc06 <__vector_9+0x34>
	{
		flag=0;
 bfe:	10 92 aa 00 	sts	0x00AA, r1	; 0x8000aa <__data_end>
		Set_Pass();
 c02:	0e 94 0a 05 	call	0xa14	; 0xa14 <Set_Pass>
	}
}
 c06:	ff 91       	pop	r31
 c08:	ef 91       	pop	r30
 c0a:	bf 91       	pop	r27
 c0c:	af 91       	pop	r26
 c0e:	9f 91       	pop	r25
 c10:	8f 91       	pop	r24
 c12:	7f 91       	pop	r23
 c14:	6f 91       	pop	r22
 c16:	5f 91       	pop	r21
 c18:	4f 91       	pop	r20
 c1a:	3f 91       	pop	r19
 c1c:	2f 91       	pop	r18
 c1e:	0f 90       	pop	r0
 c20:	0f be       	out	0x3f, r0	; 63
 c22:	0f 90       	pop	r0
 c24:	1f 90       	pop	r1
 c26:	18 95       	reti

00000c28 <_exit>:
 c28:	f8 94       	cli

00000c2a <__stop_program>:
 c2a:	ff cf       	rjmp	.-2      	; 0xc2a <__stop_program>
